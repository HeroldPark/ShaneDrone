markdown# 조이스틱 입력 표시 로직 문서

## 개요
웹 브라우저의 가상 조이스틱 입력이 ESP32를 거쳐 화면에 표시되기까지의 전체 데이터 흐름을 설명합니다.

---

## 1. 클라이언트 → 서버 (조이스틱 입력 전송)

### 1.1 조이스틱 값 계산
**파일**: `data/drone.js`  
**주기**: 50Hz (20ms마다)
```javascript
// 조이스틱 위치 읽기
const lv = L.value();  // 왼쪽 조이스틱 {x, y}
const rv = R.value();  // 오른쪽 조이스틱 {x, y}

// RC 명령 생성
rc.throttle = Math.max(0, Math.min(1, (lv.y + 1) / 2));  // 0~1
rc.yaw = Math.max(-1, Math.min(1, lv.x));                // -1~1
rc.roll = Math.max(-1, Math.min(1, rv.x));               // -1~1
rc.pitch = Math.max(-1, Math.min(1, -rv.y));             // -1~1
1.2 WebSocket 전송
javascriptif(ws && ws.readyState === 1){
  ws.send(JSON.stringify({rc}));
}
전송 데이터 예시:
json{
  "rc": {
    "throttle": 0.5,
    "yaw": 0,
    "roll": 0.27083385963703348,
    "pitch": 0.41666299325659865
  }
}

2. 서버 수신 및 처리 (ESP32)
2.1 WebSocket 메시지 수신
파일: src/web_async.cpp
함수: wsEvent()
cppcase WS_EVT_DATA: {
  AwsFrameInfo* info = (AwsFrameInfo*)arg;
  if (info->final && info->index==0 && info->len==len && info->opcode==WS_TEXT) {
    JsonDocument doc;
    if (!deserializeJson(doc, data, len)) {
      if (doc["rc"].is<JsonObject>()) {
        JsonObject r = doc["rc"].as<JsonObject>();
        g_lastRcMs = millis();
        
        if (g_webRcEnabled) {
          // 전역 변수에 저장
          controllerInput.rollNorm     = constrain(r["roll"].as<float>(), -1.f, 1.f);
          controllerInput.pitchNorm    = constrain(r["pitch"].as<float>(), -1.f, 1.f);
          controllerInput.yawNorm      = constrain(r["yaw"].as<float>(), -1.f, 1.f);
          controllerInput.throttleNorm = constrain(r["throttle"].as<float>(), 0.f, 1.f);
        }
      }
    }
  }
  break;
}
2.2 SBUS와의 충돌 방지
파일: src/main.cpp
함수: loop()
cpp// 2. 통신 데이터 처리 (500Hz)
if (currentTime - lastControlUpdate >= CONTROL_UPDATE_INTERVAL) {
  // Web RC가 비활성화일 때만 SBUS 읽기
  if (!web::isRcEnabled()) {
    readReceiverData(&controllerInput);
  }
  
  checkArmStatus(&controllerInput);
  lastControlUpdate = currentTime;
}
중요: Web RC가 ON일 때는 SBUS가 controllerInput을 덮어쓰지 않습니다.

3. 서버 → 클라이언트 (텔레메트리 브로드캐스트)
3.1 주기적 브로드캐스트
파일: src/web_async.cpp
함수: loop()
주기: 10Hz (100ms마다)
cppvoid loop() {
  dns.processNextRequest();
  
  // RC timeout 체크
  if (g_webRcEnabled && (millis() - g_lastRcMs > RC_TIMEOUT_MS)) {
    controllerInput.rollNorm = controllerInput.pitchNorm = controllerInput.yawNorm = 0.f;
    controllerInput.throttleNorm = 0.f;
  }
  
  // 10Hz 텔레메트리 브로드캐스트
  static unsigned long last = 0;
  unsigned long now = millis();
  if (now - last >= 100) {
    last = now;
    if (ws.count() > 0) {
      JsonDocument doc;
      
      // 센서 데이터
      doc["attitude"]["roll"]  = sensorData.roll;
      doc["attitude"]["pitch"] = sensorData.pitch;
      doc["attitude"]["yaw"]   = sensorData.yaw;
      
      // 조이스틱 입력값
      doc["input"]["throttle"] = controllerInput.throttleNorm;
      doc["input"]["roll"]     = controllerInput.rollNorm;
      doc["input"]["pitch"]    = controllerInput.pitchNorm;
      doc["input"]["yaw"]      = controllerInput.yawNorm;
      
      doc["rcEnabled"] = g_webRcEnabled;
      
      String out;
      serializeJson(doc, out);
      ws.textAll(out);  // 모든 클라이언트에 전송
    }
  }
}
3.2 브로드캐스트 데이터 구조
json{
  "attitude": {"roll": 0, "pitch": 0, "yaw": 0},
  "gyro": {"x": 0, "y": 0, "z": 0},
  "motors": {"fl": 1000, "fr": 1000, "rl": 1000, "rr": 1000},
  "armed": false,
  "battery": 2.83,
  "mode": "STABILIZE",
  "input": {
    "throttle": 0.5,
    "roll": 0.27,
    "pitch": 0.41,
    "yaw": 0
  },
  "rcEnabled": true
}

4. 클라이언트 UI 업데이트
4.1 WebSocket 메시지 수신
파일: data/drone.js
함수: connectWS()
javascriptws.onmessage = e => {
  try {
    const d = JSON.parse(e.data);
    updateUI(d);
    
    // 3D 드론 자세 업데이트
    if(d.attitude){
      droneData.roll = d.attitude.roll;
      droneData.pitch = d.attitude.pitch;
      droneData.yaw = d.attitude.yaw;
    }
    
    // 모터 출력 업데이트
    if(d.motors){
      droneData.motors = d.motors;
    }
  } catch(err) {
    console.error(err);
  }
};
4.2 UI 업데이트
함수: updateUI()
javascriptfunction updateUI(d){
  // 자세 정보 업데이트
  if(d.attitude){
    $('#roll').textContent = d.attitude.roll.toFixed(1) + '°';
    $('#pitch').textContent = d.attitude.pitch.toFixed(1) + '°';
    $('#yaw').textContent = d.attitude.yaw.toFixed(1) + '°';
  }
  
  // 조이스틱 입력값 표시
  if(d.input){
    $('#rcRoll').textContent = d.input.roll.toFixed(2);
    $('#rcPitch').textContent = d.input.pitch.toFixed(2);
    $('#rcYaw').textContent = d.input.yaw.toFixed(2);
    $('#rcThr').textContent = (d.input.throttle * 100).toFixed(0) + '%';
  }
  
  // RC 상태 표시
  if(d.rcEnabled !== undefined){
    rcEnabled = d.rcEnabled;
    $('#rcpill').textContent = rcEnabled ? '(RC ON)' : '(RC OFF)';
    $('#rcpill').classList.toggle('on', rcEnabled);
  }
}

전체 데이터 흐름도
┌─────────────────────────────────────────────────────────────┐
│                    브라우저 (클라이언트)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 사용자가 조이스틱 터치                                     │
│     ↓                                                       │
│  2. makeStick() → value() 계산 (x, y)                        │
│     ↓                                                       │
│  3. 20ms마다: rc 객체 생성                                    │
│     {throttle, yaw, roll, pitch}                            │
│     ↓                                                       │
│  4. WebSocket 전송 (50Hz)                                    │
│     ws.send(JSON.stringify({rc}))                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                          ↓ WebSocket
┌─────────────────────────────────────────────────────────────┐
│                    ESP32 (서버)                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  5. wsEvent() → JSON 파싱                                    │
│     ↓                                                       │
│  6. g_webRcEnabled 확인                                      │
│     ↓ (true인 경우)                                          │
│  7. controllerInput 업데이트                                 │
│     .throttleNorm, .rollNorm, .pitchNorm, .yawNorm          │
│     ↓                                                       │
│  8. main.cpp에서 SBUS 읽기 건너뜀                             │
│     if (!web::isRcEnabled()) { ... }                        │
│     ↓                                                       │
│  9. 100ms마다: loop()                                        │
│     - 모든 센서/상태 데이터 수집                                │
│     - JSON 직렬화                                            │
│     - WebSocket 브로드캐스트 (10Hz)                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                          ↓ WebSocket
┌─────────────────────────────────────────────────────────────┐
│                    브라우저 (클라이언트)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 10. ws.onmessage → JSON.parse()                             │
│     ↓                                                       │
│ 11. updateUI(data)                                          │
│     ↓                                                       │
│ 12. DOM 업데이트                                             │
│     $('#rcRoll').textContent = d.input.roll.toFixed(2)      │
│     $('#rcPitch').textContent = d.input.pitch.toFixed(2)    │
│     $('#rcYaw').textContent = d.input.yaw.toFixed(2)        │
│     $('#rcThr').textContent = (d.input.throttle*100) + '%'  │
│     ↓                                                       │
│ 13. 화면에 값 표시 완료                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘

주요 타이밍
단계주기설명조이스틱 → ESP3250Hz (20ms)업링크 전송ESP32 → 브라우저10Hz (100ms)다운링크 브로드캐스트전체 지연~100-150ms네트워크 지연 포함

주요 전역 변수
ESP32 측
cpp// web_async.cpp
static bool g_webRcEnabled = false;           // Web RC 활성화 상태
static unsigned long g_lastRcMs = 0;          // 마지막 RC 수신 시간
static const unsigned long RC_TIMEOUT_MS = 500; // RC 타임아웃

// main.cpp (extern)
extern ControllerInput controllerInput;       // 조종 입력 저장소
브라우저 측
javascript// drone.js
let ws;                    // WebSocket 연결
let rcEnabled = false;     // RC 활성화 상태
let rc = {                 // RC 명령 객체
  throttle: 0,
  yaw: 0,
  roll: 0,
  pitch: 0
};

문제 해결 이력
문제: 조이스틱 입력값이 화면에 0으로 표시됨
원인:

JSON 파싱 오류: r["roll"] | 0 대신 r["roll"].as<float>() 사용 필요
SBUS가 Web RC 값을 덮어씀

해결:

ArduinoJson v7 문법으로 수정
web::isRcEnabled() 체크 추가로 SBUS와 충돌 방지


참고 파일

src/web_async.cpp - WebSocket 서버 및 핸들러
src/main.cpp - 메인 루프 및 제어 로직
data/drone.js - 클라이언트 JavaScript
data/index.html - UI 구조
include/web.h - Web 모듈 API


작성일
2025-10-05
버전
1.0
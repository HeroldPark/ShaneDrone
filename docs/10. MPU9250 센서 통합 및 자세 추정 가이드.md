# ğŸ¯ MPU9250 ì„¼ì„œ í†µí•© ë° ìì„¸ ì¶”ì • ê°€ì´ë“œ

## ğŸ“‹ ëª©í‘œ: Arduino Nano ESP32 + MPU9250ìœ¼ë¡œ ì •í™•í•œ ìì„¸ ì¶”ì • ì‹œìŠ¤í…œ êµ¬ì¶•

**í˜„ì¬ ìƒíƒœ**: VS Code + PlatformIO í™˜ê²½ ì™„ë£Œ  
**ë‹¤ìŒ ëª©í‘œ**: MPU9250 ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ë° ì‹¤ì‹œê°„ ìì„¸ ì¶”ì •

---

## ğŸ”Œ Phase 1: í•˜ë“œì›¨ì–´ ì—°ê²° ë° ê¸°ë³¸ í…ŒìŠ¤íŠ¸ (30ë¶„)

### **1.1 MPU9250 ëª¨ë“ˆ ì—°ê²°**

#### **í•˜ë“œì›¨ì–´ ì—°ê²°ë„**
```
Arduino Nano ESP32      MPU9250 GY-9250
=====================================
3.3V           â†â†’       VCC (âš ï¸ ì ˆëŒ€ 5V ì—°ê²° ê¸ˆì§€!)
GND            â†â†’       GND  
D4 (GPIO 4)    â†â†’       SDA
D5 (GPIO 5)    â†â†’       SCL
               â†â†’       AD0 â†’ GND (I2C ì£¼ì†Œ 0x68 ì„¤ì •)

ì„ íƒì‚¬í•­:
D2             â†â†’       INT (ì¸í„°ëŸ½íŠ¸ í•€, ê³ ê¸‰ ê¸°ëŠ¥ìš©)
```

#### **ì—°ê²° ì‹œ ì£¼ì˜ì‚¬í•­**
```
âš ï¸ ì¤‘ìš”í•œ ì£¼ì˜ì‚¬í•­:
1. VCCëŠ” ë°˜ë“œì‹œ 3.3Vì— ì—°ê²° (5V ì—°ê²°ì‹œ ì„¼ì„œ ì†ìƒ!)
2. ì í¼ ì™€ì´ì–´ëŠ” 10cm ì´í•˜ë¡œ ì§§ê²Œ (ì‹ í˜¸ í’ˆì§ˆ ìœ ì§€)
3. ë¸Œë ˆë“œë³´ë“œ ì—°ê²°ì‹œ í™•ì‹¤íˆ ì‚½ì… (ì ‘ì´‰ ë¶ˆëŸ‰ ë°©ì§€)
4. GND ì—°ê²° í•„ìˆ˜ (ëª¨ë“  ë””ì§€í„¸ íšŒë¡œì˜ ê¸°ì¤€ì )
5. AD0 í•€ì„ GNDì— ì—°ê²°í•˜ì—¬ I2C ì£¼ì†Œë¥¼ 0x68ë¡œ ì„¤ì •
```

### **1.2 ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±**

#### **PlatformIO í”„ë¡œì íŠ¸ ì„¤ì •**
```
1. VS Codeì—ì„œ PlatformIO Home ì—´ê¸°
2. "New Project" í´ë¦­
3. ì„¤ì •:
   - Name: "ESP32_MPU9250_Test"
   - Board: "Arduino Nano ESP32"
   - Framework: "Arduino"
4. "Finish" í´ë¦­ í›„ ì´ˆê¸°í™” ëŒ€ê¸°
```

#### **platformio.ini ì„¤ì •**
```ini
[env:arduino_nano_esp32]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; ì‹œë¦¬ì–¼ ì„¤ì •
monitor_speed = 115200
monitor_filters = esp32_exception_decoder

; MPU9250 ì „ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬
lib_deps = 
    hideakitai/MPU9250@^0.4.7
    adafruit/Adafruit MPU6050@^2.2.4

; ë¹Œë“œ ìµœì í™”
build_flags = 
    -DCORE_DEBUG_LEVEL=3
    -DARDUINO_USB_CDC_ON_BOOT=1
```

### **1.3 I2C ì—°ê²° í…ŒìŠ¤íŠ¸**

#### **I2C ìŠ¤ìºë„ˆ ì½”ë“œ (src/main.cpp)**
```cpp
/*
 * MPU9250 ì—°ê²° í™•ì¸ìš© I2C ìŠ¤ìºë„ˆ
 * VS Code + PlatformIO í™˜ê²½
 */

#include <Arduino.h>
#include <Wire.h>

// I2C í•€ ì •ì˜
#define I2C_SDA 4
#define I2C_SCL 5

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n" + String("=").repeat(40));
    Serial.println("MPU9250 I2C ì—°ê²° í…ŒìŠ¤íŠ¸");
    Serial.println("VS Code + PlatformIO í™˜ê²½");
    Serial.println("=".repeat(40));
    
    // I2C ì´ˆê¸°í™”
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(400000);  // 400kHz
    
    Serial.printf("I2C ì´ˆê¸°í™” ì™„ë£Œ - SDA: %d, SCL: %d\n", I2C_SDA, I2C_SCL);
    Serial.println("5ì´ˆ í›„ ìŠ¤ìº” ì‹œì‘...\n");
    delay(5000);
}

void loop() {
    scanI2CDevices();
    delay(10000);  // 10ì´ˆë§ˆë‹¤ ìŠ¤ìº”
}

void scanI2CDevices() {
    byte error, address;
    int deviceCount = 0;
    
    Serial.println("I2C ë²„ìŠ¤ ìŠ¤ìº” ì¤‘...");
    Serial.println("ì£¼ì†Œë²”ìœ„: 0x01 ~ 0x7F");
    
    for (address = 1; address < 127; address++) {
        Wire.beginTransmission(address);
        error = Wire.endTransmission();
        
        if (error == 0) {
            Serial.printf("âœ… ë””ë°”ì´ìŠ¤ ë°œê²¬: 0x%02X ", address);
            
            // ì•Œë ¤ì§„ ë””ë°”ì´ìŠ¤ ì‹ë³„
            switch (address) {
                case 0x68:
                    Serial.println("(MPU9250/MPU6050 - ìì´ë¡œ/ê°€ì†ë„ê³„)");
                    testMPU9250Communication(address);
                    break;
                case 0x0C:
                    Serial.println("(AK8963 - ìë ¥ê³„, MPU9250 ë‚´ë¶€)");
                    break;
                case 0x3C:
                case 0x3D:
                    Serial.println("(SSD1306 OLED ë””ìŠ¤í”Œë ˆì´)");
                    break;
                case 0x76:
                case 0x77:
                    Serial.println("(BMP280/BME280 - ê¸°ì••ì„¼ì„œ)");
                    break;
                default:
                    Serial.println("(ì•Œ ìˆ˜ ì—†ëŠ” ë””ë°”ì´ìŠ¤)");
                    break;
            }
            deviceCount++;
        }
        else if (error == 4) {
            Serial.printf("âŒ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜: ì£¼ì†Œ 0x%02X\n", address);
        }
    }
    
    Serial.printf("\nğŸ“Š ìŠ¤ìº” ì™„ë£Œ: ì´ %dê°œ ë””ë°”ì´ìŠ¤ ë°œê²¬\n", deviceCount);
    
    if (deviceCount == 0) {
        Serial.println("\nâŒ ë””ë°”ì´ìŠ¤ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!");
        printTroubleshooting();
    } else {
        Serial.println("âœ… I2C í†µì‹  ì •ìƒ");
    }
    
    Serial.println("-".repeat(40) + "\n");
}

void testMPU9250Communication(byte address) {
    // WHO_AM_I ë ˆì§€ìŠ¤í„° ì½ê¸° (0x75)
    Wire.beginTransmission(address);
    Wire.write(0x75);  // WHO_AM_I ë ˆì§€ìŠ¤í„°
    Wire.endTransmission(false);
    
    Wire.requestFrom(address, (uint8_t)1);
    
    if (Wire.available()) {
        byte whoami = Wire.read();
        Serial.printf("  WHO_AM_I: 0x%02X ", whoami);
        
        if (whoami == 0x71) {
            Serial.println("(MPU9250 ì •ìƒ)");
        } else if (whoami == 0x68) {
            Serial.println("(MPU6050 ê°ì§€ë¨)");
        } else {
            Serial.println("(ì˜ˆìƒê³¼ ë‹¤ë¥¸ ê°’)");
        }
    } else {
        Serial.println("  í†µì‹  ì˜¤ë¥˜");
    }
}

void printTroubleshooting() {
    Serial.println("ğŸ”§ ë¬¸ì œ í•´ê²° ê°€ì´ë“œ:");
    Serial.println("1. ì—°ê²° í™•ì¸:");
    Serial.println("   - VCC â†’ 3.3V (5V ì•„ë‹˜!)");
    Serial.println("   - GND â†’ GND");
    Serial.println("   - SDA â†’ D4 (GPIO 4)");
    Serial.println("   - SCL â†’ D5 (GPIO 5)");
    Serial.println("   - AD0 â†’ GND (ì£¼ì†Œ 0x68 ì„¤ì •)");
    Serial.println();
    Serial.println("2. í•˜ë“œì›¨ì–´ ì²´í¬:");
    Serial.println("   - ì í¼ ì™€ì´ì–´ ì ‘ì´‰ ë¶ˆëŸ‰");
    Serial.println("   - ë¸Œë ˆë“œë³´ë“œ ì‚½ì… ìƒíƒœ");
    Serial.println("   - MPU9250 ëª¨ë“ˆ ì†ìƒ ì—¬ë¶€");
    Serial.println();
    Serial.println("3. ì „ì› ì²´í¬:");
    Serial.println("   - 3.3V ì „ì•• ì¸¡ì •");
    Serial.println("   - GND ì—°ê²° í™•ì¸");
}
```

#### **ì˜ˆìƒ ê²°ê³¼**
```
ì •ìƒ ì—°ê²°ì‹œ ì¶œë ¥:
========================================
MPU9250 I2C ì—°ê²° í…ŒìŠ¤íŠ¸
VS Code + PlatformIO í™˜ê²½
========================================
I2C ì´ˆê¸°í™” ì™„ë£Œ - SDA: 4, SCL: 5
5ì´ˆ í›„ ìŠ¤ìº” ì‹œì‘...

I2C ë²„ìŠ¤ ìŠ¤ìº” ì¤‘...
ì£¼ì†Œë²”ìœ„: 0x01 ~ 0x7F
âœ… ë””ë°”ì´ìŠ¤ ë°œê²¬: 0x68 (MPU9250/MPU6050 - ìì´ë¡œ/ê°€ì†ë„ê³„)
  WHO_AM_I: 0x71 (MPU9250 ì •ìƒ)

ğŸ“Š ìŠ¤ìº” ì™„ë£Œ: ì´ 1ê°œ ë””ë°”ì´ìŠ¤ ë°œê²¬
âœ… I2C í†µì‹  ì •ìƒ
```

---

## ğŸ“Š Phase 2: MPU9250 ê¸°ë³¸ ë°ì´í„° ì½ê¸° (45ë¶„)

### **2.1 ê¸°ë³¸ ì„¼ì„œ ë°ì´í„° ì½ê¸°**

#### **ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±**
```
í”„ë¡œì íŠ¸ëª…: "ESP32_MPU9250_Basic"
ì´ì „ê³¼ ë™ì¼í•œ ì„¤ì • ì‚¬ìš©
```

#### **ê¸°ë³¸ ì„¼ì„œ ì½ê¸° ì½”ë“œ**
```cpp
/*
 * MPU9250 ê¸°ë³¸ ì„¼ì„œ ë°ì´í„° ì½ê¸°
 * ê°€ì†ë„ê³„, ìì´ë¡œìŠ¤ì½”í”„, ìë ¥ê³„ ë°ì´í„° ìˆ˜ì§‘
 */

#include <Arduino.h>
#include <Wire.h>
#include <MPU9250.h>

// MPU9250 ê°ì²´ ìƒì„±
MPU9250 mpu;

// I2C í•€ ì •ì˜  
#define I2C_SDA 4
#define I2C_SCL 5

// ì„¼ì„œ ë°ì´í„° êµ¬ì¡°ì²´
struct SensorData {
    // ê°€ì†ë„ (m/sÂ²)
    float accel_x, accel_y, accel_z;
    // ìì´ë¡œìŠ¤ì½”í”„ (deg/s)
    float gyro_x, gyro_y, gyro_z;
    // ìë ¥ê³„ (Î¼T)
    float mag_x, mag_y, mag_z;
    // ì˜¨ë„ (Â°C)
    float temperature;
    // íƒ€ì„ìŠ¤íƒ¬í”„
    unsigned long timestamp;
};

SensorData currentData;

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n" + String("=").repeat(50));
    Serial.println("MPU9250 ê¸°ë³¸ ì„¼ì„œ ë°ì´í„° ì½ê¸°");
    Serial.println("=".repeat(50));
    
    // I2C ì´ˆê¸°í™”
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(400000);
    
    // MPU9250 ì´ˆê¸°í™”
    if (!initializeMPU9250()) {
        Serial.println("âŒ MPU9250 ì´ˆê¸°í™” ì‹¤íŒ¨!");
        Serial.println("ì—°ê²°ì„ í™•ì¸í•˜ê³  ë¦¬ì…‹í•˜ì„¸ìš”.");
        while (1) {
            delay(1000);
        }
    }
    
    Serial.println("âœ… MPU9250 ì´ˆê¸°í™” ì„±ê³µ!");
    printSensorInfo();
    
    Serial.println("\nğŸ“Š ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„° (1ì´ˆ ê°„ê²©):");
    Serial.println("ì‹œê°„(ms)\tê°€ì†ë„(m/sÂ²)\t\tìì´ë¡œ(deg/s)\t\tìë ¥ê³„(Î¼T)\t\tì˜¨ë„(Â°C)");
    Serial.println("-".repeat(100));
}

void loop() {
    // ì„¼ì„œ ë°ì´í„° ì½ê¸°
    if (readSensorData()) {
        printSensorData();
        
        // ë°ì´í„° í’ˆì§ˆ ì²´í¬
        checkDataQuality();
    } else {
        Serial.println("âŒ ì„¼ì„œ ë°ì´í„° ì½ê¸° ì‹¤íŒ¨");
    }
    
    delay(1000);  // 1ì´ˆ ê°„ê²©
}

bool initializeMPU9250() {
    Serial.println("MPU9250 ì´ˆê¸°í™” ì¤‘...");
    
    // MPU9250 ì—°ê²° í™•ì¸
    if (!mpu.setup(0x68)) {
        Serial.println("MPU9250 ì—°ê²° ì‹¤íŒ¨");
        return false;
    }
    
    delay(1000);  // ì•ˆì •í™” ëŒ€ê¸°
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ (ì„ íƒì‚¬í•­)
    Serial.println("ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì¤‘... (ì›€ì§ì´ì§€ ë§ˆì„¸ìš”!)");
    mpu.calibrateAccelGyro();
    
    Serial.println("ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì¤‘... (8ì ëª¨ì–‘ìœ¼ë¡œ íšŒì „ì‹œí‚¤ì„¸ìš”!)");
    Serial.println("10ì´ˆ í›„ ìë™ ì‹œì‘...");
    delay(10000);
    
    mpu.calibrateMag();
    
    return true;
}

bool readSensorData() {
    if (!mpu.update()) {
        return false;
    }
    
    currentData.timestamp = millis();
    
    // ê°€ì†ë„ ë°ì´í„° (g â†’ m/sÂ² ë³€í™˜)
    currentData.accel_x = mpu.getAccX() * 9.81f;
    currentData.accel_y = mpu.getAccY() * 9.81f;
    currentData.accel_z = mpu.getAccZ() * 9.81f;
    
    // ìì´ë¡œìŠ¤ì½”í”„ ë°ì´í„° (deg/s)
    currentData.gyro_x = mpu.getGyroX();
    currentData.gyro_y = mpu.getGyroY();
    currentData.gyro_z = mpu.getGyroZ();
    
    // ìë ¥ê³„ ë°ì´í„° (Î¼T)
    currentData.mag_x = mpu.getMagX();
    currentData.mag_y = mpu.getMagY();
    currentData.mag_z = mpu.getMagZ();
    
    // ì˜¨ë„ ë°ì´í„°
    currentData.temperature = mpu.getTemperature();
    
    return true;
}

void printSensorData() {
    Serial.printf("%lu\t", currentData.timestamp);
    
    // ê°€ì†ë„ (ì†Œìˆ˜ì  2ìë¦¬)
    Serial.printf("%.2f,%.2f,%.2f\t", 
                 currentData.accel_x, 
                 currentData.accel_y, 
                 currentData.accel_z);
    
    // ìì´ë¡œìŠ¤ì½”í”„ (ì†Œìˆ˜ì  1ìë¦¬)
    Serial.printf("%.1f,%.1f,%.1f\t", 
                 currentData.gyro_x, 
                 currentData.gyro_y, 
                 currentData.gyro_z);
    
    // ìë ¥ê³„ (ì†Œìˆ˜ì  1ìë¦¬)
    Serial.printf("%.1f,%.1f,%.1f\t", 
                 currentData.mag_x, 
                 currentData.mag_y, 
                 currentData.mag_z);
    
    // ì˜¨ë„ (ì†Œìˆ˜ì  1ìë¦¬)
    Serial.printf("%.1f\n", currentData.temperature);
}

void printSensorInfo() {
    Serial.println("\nğŸ“‹ ì„¼ì„œ ì •ë³´:");
    Serial.println("ê°€ì†ë„ê³„:");
    Serial.printf("  - ë²”ìœ„: Â±%dg\n", 8);  // ì¼ë°˜ì ìœ¼ë¡œ Â±8g ì„¤ì •
    Serial.printf("  - í•´ìƒë„: %.3f mg/LSB\n", 8000.0/32768.0);
    
    Serial.println("ìì´ë¡œìŠ¤ì½”í”„:");
    Serial.printf("  - ë²”ìœ„: Â±%dÂ°/s\n", 1000);  // ì¼ë°˜ì ìœ¼ë¡œ Â±1000Â°/s ì„¤ì •
    Serial.printf("  - í•´ìƒë„: %.3f Â°/s/LSB\n", 2000.0/32768.0);
    
    Serial.println("ìë ¥ê³„:");
    Serial.println("  - ë²”ìœ„: Â±4800Î¼T");
    Serial.println("  - í•´ìƒë„: 0.6Î¼T/LSB");
    
    Serial.println("ì˜¨ë„ì„¼ì„œ:");
    Serial.println("  - ë²”ìœ„: -40Â°C ~ +85Â°C");
    Serial.println("  - ì •í™•ë„: Â±1Â°C");
}

void checkDataQuality() {
    static int errorCount = 0;
    bool dataOK = true;
    
    // ê°€ì†ë„ ë°ì´í„° ì²´í¬ (Â±50m/sÂ² ë²”ìœ„)
    if (abs(currentData.accel_x) > 50 || 
        abs(currentData.accel_y) > 50 || 
        abs(currentData.accel_z) > 50) {
        Serial.println("âš ï¸  ê°€ì†ë„ ë°ì´í„° ì´ìƒ");
        dataOK = false;
    }
    
    // ìì´ë¡œìŠ¤ì½”í”„ ë°ì´í„° ì²´í¬ (Â±2000Â°/s ë²”ìœ„)
    if (abs(currentData.gyro_x) > 2000 || 
        abs(currentData.gyro_y) > 2000 || 
        abs(currentData.gyro_z) > 2000) {
        Serial.println("âš ï¸  ìì´ë¡œìŠ¤ì½”í”„ ë°ì´í„° ì´ìƒ");
        dataOK = false;
    }
    
    // ìë ¥ê³„ ë°ì´í„° ì²´í¬ (0ì´ë©´ ë¬¸ì œ)
    if (currentData.mag_x == 0 && 
        currentData.mag_y == 0 && 
        currentData.mag_z == 0) {
        Serial.println("âš ï¸  ìë ¥ê³„ ë°ì´í„° ì—†ìŒ");
        dataOK = false;
    }
    
    // ì—ëŸ¬ ì¹´ìš´íŒ…
    if (!dataOK) {
        errorCount++;
        if (errorCount > 5) {
            Serial.println("âŒ ì—°ì† ì—ëŸ¬ ë°œìƒ - ì„¼ì„œ ì—°ê²° í™•ì¸ í•„ìš”");
            errorCount = 0;
        }
    } else {
        errorCount = 0;
    }
}
```

### **2.2 ì‹¤ì‹œê°„ ë°ì´í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ**

#### **ì›¹ ê¸°ë°˜ ëª¨ë‹ˆí„°ë§ ì½”ë“œ**
```cpp
/*
 * MPU9250 ì‹¤ì‹œê°„ ì›¹ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
 * WiFi + WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ ë°ì´í„° ì „ì†¡
 */

#include <Arduino.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <MPU9250.h>

// WiFi ì„¤ì •
const char* ssid = "ESP32_MPU9250";
const char* password = "sensor123";

// ì„œë²„ ê°ì²´
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

// MPU9250 ê°ì²´
MPU9250 mpu;

// ì„¼ì„œ ë°ì´í„°
struct RealTimeData {
    float roll, pitch, yaw;
    float accel_x, accel_y, accel_z;
    float gyro_x, gyro_y, gyro_z;
    float mag_x, mag_y, mag_z;
    float temperature;
    unsigned long timestamp;
};

RealTimeData realtimeData;

void setup() {
    Serial.begin(115200);
    
    // MPU9250 ì´ˆê¸°í™”
    Wire.begin(4, 5);
    if (!mpu.setup(0x68)) {
        Serial.println("MPU9250 ì´ˆê¸°í™” ì‹¤íŒ¨!");
        return;
    }
    
    // WiFi AP ëª¨ë“œ ì‹œì‘
    WiFi.softAP(ssid, password);
    IPAddress IP = WiFi.softAPIP();
    Serial.printf("WiFi AP ì‹œì‘ - IP: %s\n", IP.toString().c_str());
    
    // ì›¹ ì„œë²„ ì„¤ì •
    setupWebServer();
    
    Serial.println("ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ì†í•˜ì„¸ìš”:");
    Serial.printf("http://%s\n", IP.toString().c_str());
}

void loop() {
    // ì„¼ì„œ ë°ì´í„° ì—…ë°ì´íŠ¸
    if (mpu.update()) {
        updateSensorData();
        
        // ì›¹ì†Œì¼“ìœ¼ë¡œ ë°ì´í„° ì „ì†¡ (100Hz)
        static unsigned long lastSend = 0;
        if (millis() - lastSend >= 10) {
            sendWebSocketData();
            lastSend = millis();
        }
    }
    
    delay(1);
}

void updateSensorData() {
    realtimeData.timestamp = millis();
    
    // ê°€ì†ë„ ë°ì´í„°
    realtimeData.accel_x = mpu.getAccX();
    realtimeData.accel_y = mpu.getAccY();
    realtimeData.accel_z = mpu.getAccZ();
    
    // ìì´ë¡œ ë°ì´í„°
    realtimeData.gyro_x = mpu.getGyroX();
    realtimeData.gyro_y = mpu.getGyroY();
    realtimeData.gyro_z = mpu.getGyroZ();
    
    // ìë ¥ê³„ ë°ì´í„°
    realtimeData.mag_x = mpu.getMagX();
    realtimeData.mag_y = mpu.getMagY();
    realtimeData.mag_z = mpu.getMagZ();
    
    // ì˜¨ë„
    realtimeData.temperature = mpu.getTemperature();
    
    // ìì„¸ ê°ë„ ê³„ì‚° (ê°„ë‹¨í•œ ë°©ë²•)
    realtimeData.roll = mpu.getRoll();
    realtimeData.pitch = mpu.getPitch();
    realtimeData.yaw = mpu.getYaw();
}

void sendWebSocketData() {
    StaticJsonDocument<512> doc;
    
    doc["timestamp"] = realtimeData.timestamp;
    doc["accel"]["x"] = realtimeData.accel_x;
    doc["accel"]["y"] = realtimeData.accel_y;
    doc["accel"]["z"] = realtimeData.accel_z;
    doc["gyro"]["x"] = realtimeData.gyro_x;
    doc["gyro"]["y"] = realtimeData.gyro_y;
    doc["gyro"]["z"] = realtimeData.gyro_z;
    doc["mag"]["x"] = realtimeData.mag_x;
    doc["mag"]["y"] = realtimeData.mag_y;
    doc["mag"]["z"] = realtimeData.mag_z;
    doc["attitude"]["roll"] = realtimeData.roll;
    doc["attitude"]["pitch"] = realtimeData.pitch;
    doc["attitude"]["yaw"] = realtimeData.yaw;
    doc["temperature"] = realtimeData.temperature;
    
    String jsonString;
    serializeJson(doc, jsonString);
    
    ws.textAll(jsonString);
}

void setupWebServer() {
    // ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    ws.onEvent([](AsyncWebSocket *server, AsyncWebSocketClient *client, 
                  AwsEventType type, void *arg, uint8_t *data, size_t len) {
        if (type == WS_EVT_CONNECT) {
            Serial.printf("ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: %u\n", client->id());
        } else if (type == WS_EVT_DISCONNECT) {
            Serial.printf("ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸ í•´ì œ: %u\n", client->id());
        }
    });
    
    server.addHandler(&ws);
    
    // HTML í˜ì´ì§€ ì œê³µ
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send_P(200, "text/html", htmlPage);
    });
    
    server.begin();
    Serial.println("ì›¹ ì„œë²„ ì‹œì‘ ì™„ë£Œ");
}

// HTML í˜ì´ì§€ (ê°„ë‹¨í•œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§)
const char htmlPage[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>MPU9250 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; }
        .sensor-box { 
            border: 1px solid #ccc; 
            padding: 15px; 
            border-radius: 8px;
            min-width: 200px;
        }
        .value { font-size: 1.2em; font-weight: bold; color: #2196F3; }
        .timestamp { font-size: 0.9em; color: #666; }
        #status { margin-bottom: 20px; }
        .connected { color: green; }
        .disconnected { color: red; }
    </style>
</head>
<body>
    <h1>MPU9250 ì‹¤ì‹œê°„ ì„¼ì„œ ëª¨ë‹ˆí„°</h1>
    
    <div id="status" class="disconnected">ì—°ê²° ì¤‘...</div>
    
    <div class="container">
        <div class="sensor-box">
            <h3>ìì„¸ (ë„)</h3>
            <div>Roll: <span id="roll" class="value">0.0</span>Â°</div>
            <div>Pitch: <span id="pitch" class="value">0.0</span>Â°</div>
            <div>Yaw: <span id="yaw" class="value">0.0</span>Â°</div>
        </div>
        
        <div class="sensor-box">
            <h3>ê°€ì†ë„ (g)</h3>
            <div>X: <span id="acc_x" class="value">0.0</span></div>
            <div>Y: <span id="acc_y" class="value">0.0</span></div>
            <div>Z: <span id="acc_z" class="value">0.0</span></div>
        </div>
        
        <div class="sensor-box">
            <h3>ìì´ë¡œ (Â°/s)</h3>
            <div>X: <span id="gyro_x" class="value">0.0</span></div>
            <div>Y: <span id="gyro_y" class="value">0.0</span></div>
            <div>Z: <span id="gyro_z" class="value">0.0</span></div>
        </div>
        
        <div class="sensor-box">
            <h3>ìë ¥ê³„ (Î¼T)</h3>
            <div>X: <span id="mag_x" class="value">0.0</span></div>
            <div>Y: <span id="mag_y" class="value">0.0</span></div>
            <div>Z: <span id="mag_z" class="value">0.0</span></div>
        </div>
        
        <div class="sensor-box">
            <h3>ê¸°íƒ€</h3>
            <div>ì˜¨ë„: <span id="temp" class="value">0.0</span>Â°C</div>
            <div class="timestamp">ì‹œê°„: <span id="timestamp">0</span>ms</div>
        </div>
    </div>

    <script>
        const ws = new WebSocket('ws://' + window.location.host + '/ws');
        const status = document.getElementById('status');
        
        ws.onopen = function() {
            status.textContent = 'âœ… ì—°ê²°ë¨';
            status.className = 'connected';
        };
        
        ws.onclose = function() {
            status.textContent = 'âŒ ì—°ê²° ëŠì–´ì§';
            status.className = 'disconnected';
        };
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            // ìì„¸ ë°ì´í„° ì—…ë°ì´íŠ¸
            document.getElementById('roll').textContent = data.attitude.roll.toFixed(1);
            document.getElementById('pitch').textContent = data.attitude.pitch.toFixed(1);
            document.getElementById('yaw').textContent = data.attitude.yaw.toFixed(1);
            
            // ê°€ì†ë„ ë°ì´í„° ì—…ë°ì´íŠ¸
            document.getElementById('acc_x').textContent = data.accel.x.toFixed(2);
            document.getElementById('acc_y').textContent = data.accel.y.toFixed(2);
            document.getElementById('acc_z').textContent = data.accel.z.toFixed(2);
            
            // ìì´ë¡œ ë°ì´í„° ì—…ë°ì´íŠ¸
            document.getElementById('gyro_x').textContent = data.gyro.x.toFixed(1);
            document.getElementById('gyro_y').textContent = data.gyro.y.toFixed(1);
            document.getElementById('gyro_z').textContent = data.gyro.z.toFixed(1);
            
            // ìë ¥ê³„ ë°ì´í„° ì—…ë°ì´íŠ¸
            document.getElementById('mag_x').textContent = data.mag.x.toFixed(1);
            document.getElementById('mag_y').textContent = data.mag.y.toFixed(1);
            document.getElementById('mag_z').textContent = data.mag.z.toFixed(1);
            
            // ê¸°íƒ€ ë°ì´í„° ì—…ë°ì´íŠ¸
            document.getElementById('temp').textContent = data.temperature.toFixed(1);
            document.getElementById('timestamp').textContent = data.timestamp;
        };
    </script>
</body>
</html>
)rawliteral";
```

---

## ğŸ§® Phase 3: ê³ ê¸‰ ìì„¸ ì¶”ì • ì•Œê³ ë¦¬ì¦˜ (90ë¶„)

### **3.1 ìƒë³´ í•„í„° êµ¬í˜„**

#### **ìƒˆ í”„ë¡œì íŠ¸: "ESP32_AttitudeEstimation"**

```cpp
/*
 * ê³ ê¸‰ ìì„¸ ì¶”ì • ì‹œìŠ¤í…œ
 * ìƒë³´ í•„í„° + ì¹¼ë§Œ í•„í„° êµ¬í˜„
 */

#include <Arduino.h>
#include <MPU9250.h>
#include <math.h>

// MPU9250 ê°ì²´
MPU9250 mpu;

// ìì„¸ ì¶”ì • í´ë˜ìŠ¤
class AttitudeEstimator {
private:
    // ìƒë³´ í•„í„° ê³„ìˆ˜ (0.98 = ìì´ë¡œ 98%, ê°€ì†ë„ 2%)
    const float alpha = 0.98f;
    
    // í˜„ì¬ ìì„¸ ê°ë„ (ë¼ë””ì•ˆ)
    float roll = 0.0f;
    float pitch = 0.0f;
    float yaw = 0.0f;
    
    // ì´ì „ ì‹œê°„
    unsigned long lastUpdate = 0;
    
    // ì €ì—­ í†µê³¼ í•„í„° í´ë˜ìŠ¤
    class LowPassFilter {
    private:
        float output = 0.0f;
        float alpha;
        
    public:
        LowPassFilter(float cutoffFreq, float sampleRate) {
            float RC = 1.0f / (2.0f * PI * cutoffFreq);
            float dt = 1.0f / sampleRate;
            alpha = dt / (dt + RC);
        }
        
        float update(float input) {
            output = alpha * input + (1.0f - alpha) * output;
            return output;
        }
        
        void reset() { output = 0.0f; }
    };
    
    // ê° ì¶•ë³„ í•„í„°
    LowPassFilter accelFilterX, accelFilterY, accelFilterZ;
    LowPassFilter gyroFilterX, gyroFilterY, gyroFilterZ;
    
public:
    AttitudeEstimator() : 
        accelFilterX(20.0f, 1000.0f),  // 20Hz ì»·ì˜¤í”„, 1kHz ìƒ˜í”Œë§
        accelFilterY(20.0f, 1000.0f),
        accelFilterZ(20.0f, 1000.0f),
        gyroFilterX(50.0f, 1000.0f),   // 50Hz ì»·ì˜¤í”„
        gyroFilterY(50.0f, 1000.0f),
        gyroFilterZ(50.0f, 1000.0f) {}
    
    void update(float ax, float ay, float az, 
                float gx, float gy, float gz,
                float mx, float my, float mz) {
        
        unsigned long now = micros();
        float dt = (now - lastUpdate) / 1000000.0f;  // ì´ˆ ë‹¨ìœ„
        lastUpdate = now;
        
        if (dt > 0.1f) dt = 0.001f;  // ì´ˆê¸°ê°’ ë˜ëŠ” ë¹„ì •ìƒì ì¸ dt ë°©ì§€
        
        // ì„¼ì„œ ë°ì´í„° í•„í„°ë§
        ax = accelFilterX.update(ax);
        ay = accelFilterY.update(ay);
        az = accelFilterZ.update(az);
        
        gx = gyroFilterX.update(gx);
        gy = gyroFilterY.update(gy);
        gz = gyroFilterZ.update(gz);
        
        // ìì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜
        gx *= DEG_TO_RAD;
        gy *= DEG_TO_RAD;
        gz *= DEG_TO_RAD;
        
        // ìì´ë¡œìŠ¤ì½”í”„ë¡œë¶€í„° ê°ë„ ì˜ˆì¸¡
        float gyroRoll = roll + gx * dt;
        float gyroPitch = pitch + gy * dt;
        float gyroYaw = yaw + gz * dt;
        
        // ê°€ì†ë„ê³„ë¡œë¶€í„° ë¡¤/í”¼ì¹˜ ê³„ì‚°
        float accelRoll = atan2(ay, az);
        float accelPitch = atan2(-ax, sqrt(ay*ay + az*az));
        
        // ìƒë³´ í•„í„° ì ìš©
        roll = alpha * gyroRoll + (1.0f - alpha) * accelRoll;
        pitch = alpha * gyroPitch + (1.0f - alpha) * accelPitch;
        
        // ìë ¥ê³„ë¥¼ ì´ìš©í•œ ìš” ê°ë„ ê³„ì‚°
        if (mx != 0 || my != 0) {  // ìë ¥ê³„ ë°ì´í„°ê°€ ìœ íš¨í•œ ê²½ìš°
            // ìë ¥ê³„ ë°ì´í„°ë¥¼ ìˆ˜í‰ë©´ì— íˆ¬ì˜
            float magX = mx * cos(pitch) + mz * sin(pitch);
            float magY = mx * sin(roll) * sin(pitch) + my * cos(roll) - mz * sin(roll) * cos(pitch);
            
            float magYaw = atan2(-magY, magX);
            
            // ìš” ê°ë„ì— ìƒë³´ í•„í„° ì ìš© (ìë ¥ê³„ ê°€ì¤‘ì¹˜ ë‚®ì¶¤)
            yaw = 0.95f * gyroYaw + 0.05f * magYaw;
        } else {
            yaw = gyroYaw;  // ìë ¥ê³„ ì—†ì´ëŠ” ìì´ë¡œìŠ¤ì½”í”„ë§Œ ì‚¬ìš©
        }
        
        // ê°ë„ ë²”ìœ„ ì •ê·œí™” (-Ï€ ~ Ï€)
        roll = normalizeAngle(roll);
        pitch = normalizeAngle(pitch);
        yaw = normalizeAngle(yaw);
    }
    
    float getRoll() const { return roll * RAD_TO_DEG; }
    float getPitch() const { return pitch * RAD_TO_DEG; }
    float getYaw() const { return yaw * RAD_TO_DEG; }
    
    void reset() {
        roll = pitch = yaw = 0.0f;
        lastUpdate = micros();
        
        accelFilterX.reset();
        accelFilterY.reset();
        accelFilterZ.reset();
        gyroFilterX.reset();
        gyroFilterY.reset();
        gyroFilterZ.reset();
    }
    
private:
    float normalizeAngle(float angle) {
        while (angle > PI) angle -= 2.0f * PI;
        while (angle < -PI) angle += 2.0f * PI;
        return angle;
    }
};

// ì „ì—­ ê°ì²´
AttitudeEstimator attitude;

// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
struct PerformanceStats {
    unsigned long loopCount = 0;
    unsigned long maxLoopTime = 0;
    unsigned long totalLoopTime = 0;
    unsigned long lastReport = 0;
};

PerformanceStats perfStats;

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n" + String("=").repeat(60));
    Serial.println("ê³ ê¸‰ ìì„¸ ì¶”ì • ì‹œìŠ¤í…œ - ìƒë³´ í•„í„° êµ¬í˜„");
    Serial.println("=".repeat(60));
    
    // MPU9250 ì´ˆê¸°í™”
    Wire.begin(4, 5);
    Wire.setClock(400000);
    
    if (!mpu.setup(0x68)) {
        Serial.println("âŒ MPU9250 ì´ˆê¸°í™” ì‹¤íŒ¨!");
        while (1) delay(1000);
    }
    
    Serial.println("âœ… MPU9250 ì´ˆê¸°í™” ì„±ê³µ");
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜
    Serial.println("ğŸ“Š ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì¤‘... (ì •ì§€ ìƒíƒœ ìœ ì§€!)");
    delay(2000);
    mpu.calibrateAccelGyro();
    
    Serial.println("ğŸ“Š ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì¤‘... (8ì ëª¨ì–‘ìœ¼ë¡œ íšŒì „!)");
    Serial.println("5ì´ˆ í›„ ì‹œì‘...");
    delay(5000);
    mpu.calibrateMag();
    
    Serial.println("âœ… ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ");
    
    // ìì„¸ ì¶”ì •ê¸° ì´ˆê¸°í™”
    attitude.reset();
    
    Serial.println("\nğŸ“Š ì‹¤ì‹œê°„ ìì„¸ ì¶”ì • ì‹œì‘ (1000Hz ëª©í‘œ)");
    Serial.println("ì‹œê°„(ms)\tRoll(Â°)\tPitch(Â°)\tYaw(Â°)\të£¨í”„ì‹œê°„(Î¼s)");
    Serial.println("-".repeat(70));
    
    perfStats.lastReport = millis();
}

void loop() {
    unsigned long loopStart = micros();
    
    // MPU9250 ë°ì´í„° ì½ê¸°
    if (mpu.update()) {
        // ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        float ax = mpu.getAccX();
        float ay = mpu.getAccY();
        float az = mpu.getAccZ();
        
        float gx = mpu.getGyroX();
        float gy = mpu.getGyroY();
        float gz = mpu.getGyroZ();
        
        float mx = mpu.getMagX();
        float my = mpu.getMagY();
        float mz = mpu.getMagZ();
        
        // ìì„¸ ì¶”ì • ì—…ë°ì´íŠ¸
        attitude.update(ax, ay, az, gx, gy, gz, mx, my, mz);
        
        // ê²°ê³¼ ì¶œë ¥ (100Hzë¡œ ì œí•œ)
        static unsigned long lastPrint = 0;
        if (micros() - lastPrint >= 10000) {  // 10ms = 100Hz
            lastPrint = micros();
            
            Serial.printf("%lu\t\t%.1f\t%.1f\t%.1f\t%lu\n",
                         millis(),
                         attitude.getRoll(),
                         attitude.getPitch(), 
                         attitude.getYaw(),
                         micros() - loopStart);
        }
    }
    
    // ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
    updatePerformanceStats(micros() - loopStart);
    
    // 1000Hz ëª©í‘œ (1ms ì£¼ê¸°)
    delayMicroseconds(100);  // ìµœì†Œ ì§€ì—°
}

void updatePerformanceStats(unsigned long loopTime) {
    perfStats.loopCount++;
    perfStats.totalLoopTime += loopTime;
    
    if (loopTime > perfStats.maxLoopTime) {
        perfStats.maxLoopTime = loopTime;
    }
    
    // 5ì´ˆë§ˆë‹¤ ì„±ëŠ¥ ë¦¬í¬íŠ¸
    if (millis() - perfStats.lastReport >= 5000) {
        printPerformanceReport();
        perfStats.lastReport = millis();
        
        // í†µê³„ ë¦¬ì…‹
        perfStats.loopCount = 0;
        perfStats.totalLoopTime = 0;
        perfStats.maxLoopTime = 0;
    }
}

void printPerformanceReport() {
    if (perfStats.loopCount > 0) {
        float avgLoopTime = (float)perfStats.totalLoopTime / perfStats.loopCount;
        float actualFreq = 1000000.0f / avgLoopTime;
        
        Serial.println("\n" + String("=").repeat(50));
        Serial.println("ğŸ“Š ì„±ëŠ¥ ë¦¬í¬íŠ¸ (ìµœê·¼ 5ì´ˆ)");
        Serial.println("=".repeat(50));
        Serial.printf("í‰ê·  ë£¨í”„ ì‹œê°„: %.1f Î¼s\n", avgLoopTime);
        Serial.printf("ìµœëŒ€ ë£¨í”„ ì‹œê°„: %lu Î¼s\n", perfStats.maxLoopTime);
        Serial.printf("ì‹¤ì œ ì£¼íŒŒìˆ˜: %.0f Hz\n", actualFreq);
        Serial.printf("ì´ ë£¨í”„ ìˆ˜: %lu\n", perfStats.loopCount);
        Serial.printf("í˜„ì¬ ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
        
        if (actualFreq < 500) {
            Serial.println("âš ï¸  ëª©í‘œ ì£¼íŒŒìˆ˜ ë¯¸ë‹¬ - ì½”ë“œ ìµœì í™” í•„ìš”");
        } else if (actualFreq >= 1000) {
            Serial.println("âœ… ëª©í‘œ ì„±ëŠ¥ ë‹¬ì„±!");
        }
        
        Serial.println("=".repeat(50) + "\n");
    }
}
```

### **3.2 ì¹¼ë§Œ í•„í„° êµ¬í˜„ (ê³ ê¸‰)**

#### **í™•ì¥ ì¹¼ë§Œ í•„í„° í´ë˜ìŠ¤**
```cpp
/*
 * í™•ì¥ ì¹¼ë§Œ í•„í„°ë¥¼ ì´ìš©í•œ ê³ ì •ë°€ ìì„¸ ì¶”ì •
 * ë” ì •í™•í•˜ì§€ë§Œ ê³„ì‚°ëŸ‰ì´ ë§ìŒ
 */

class ExtendedKalmanFilter {
private:
    // ìƒíƒœ ë²¡í„°: [roll, pitch, yaw, gyro_bias_x, gyro_bias_y, gyro_bias_z]
    static const int STATE_SIZE = 6;
    static const int MEASUREMENT_SIZE = 6;
    
    // ìƒíƒœ ë²¡í„°
    float state[STATE_SIZE] = {0};
    
    // ê³µë¶„ì‚° í–‰ë ¬ P (6x6)
    float P[STATE_SIZE][STATE_SIZE] = {0};
    
    // í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ Q
    float Q[STATE_SIZE][STATE_SIZE] = {0};
    
    // ì¸¡ì • ë…¸ì´ì¦ˆ R
    float R[MEASUREMENT_SIZE][MEASUREMENT_SIZE] = {0};
    
    // ì‹œê°„ ê°„ê²©
    float dt = 0.001f;
    
public:
    ExtendedKalmanFilter() {
        initializeMatrices();
    }
    
    void initializeMatrices() {
        // ì´ˆê¸° ê³µë¶„ì‚° í–‰ë ¬ (ëŒ€ê°ì„  ìš”ì†Œë§Œ)
        for (int i = 0; i < STATE_SIZE; i++) {
            for (int j = 0; j < STATE_SIZE; j++) {
                P[i][j] = (i == j) ? 1.0f : 0.0f;
            }
        }
        
        // í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ (ìì´ë¡œ ë…¸ì´ì¦ˆ + ë°”ì´ì–´ìŠ¤ ë“œë¦¬í”„íŠ¸)
        Q[0][0] = 0.01f;  // roll ë…¸ì´ì¦ˆ
        Q[1][1] = 0.01f;  // pitch ë…¸ì´ì¦ˆ
        Q[2][2] = 0.01f;  // yaw ë…¸ì´ì¦ˆ
        Q[3][3] = 0.001f; // gyro bias x
        Q[4][4] = 0.001f; // gyro bias y
        Q[5][5] = 0.001f; // gyro bias z
        
        // ì¸¡ì • ë…¸ì´ì¦ˆ (ê°€ì†ë„ê³„ + ìë ¥ê³„)
        R[0][0] = 0.1f;   // accel x
        R[1][1] = 0.1f;   // accel y
        R[2][2] = 0.1f;   // accel z
        R[3][3] = 0.5f;   // mag x
        R[4][4] = 0.5f;   // mag y
        R[5][5] = 0.5f;   // mag z
    }
    
    void predict(float gx, float gy, float gz, float deltaTime) {
        dt = deltaTime;
        
        // ìì´ë¡œ ë°”ì´ì–´ìŠ¤ ë³´ì •
        float corrected_gx = gx - state[3];
        float corrected_gy = gy - state[4];
        float corrected_gz = gz - state[5];
        
        // ìƒíƒœ ì˜ˆì¸¡ (ì˜¤ì¼ëŸ¬ ì ë¶„)
        state[0] += corrected_gx * dt;  // roll
        state[1] += corrected_gy * dt;  // pitch
        state[2] += corrected_gz * dt;  // yaw
        // ë°”ì´ì–´ìŠ¤ëŠ” ë³€í™” ì—†ìŒ (state[3], state[4], state[5])
        
        // ê°ë„ ì •ê·œí™”
        state[0] = normalizeAngle(state[0]);
        state[1] = normalizeAngle(state[1]);
        state[2] = normalizeAngle(state[2]);
        
        // ê³µë¶„ì‚° ì˜ˆì¸¡ (ê°„ë‹¨í™”ëœ ë²„ì „)
        for (int i = 0; i < 3; i++) {
            P[i][i] += Q[i][i] * dt * dt;
        }
        for (int i = 3; i < 6; i++) {
            P[i][i] += Q[i][i] * dt;
        }
    }
    
    void update(float ax, float ay, float az, float mx, float my, float mz) {
        // ì¸¡ì •ê°’ìœ¼ë¡œë¶€í„° ì˜ˆìƒë˜ëŠ” ìì„¸ ê³„ì‚°
        float measured_roll = atan2(ay, az);
        float measured_pitch = atan2(-ax, sqrt(ay*ay + az*az));
        
        // ìë ¥ê³„ë¡œë¶€í„° ìš” ê°ë„ (ê°„ë‹¨í™”)
        float measured_yaw = atan2(-my, mx);
        
        // í˜ì‹  (innovation) ê³„ì‚°
        float innovation[6];
        innovation[0] = ax;  // ê°€ì†ë„ ì¸¡ì •ê°’ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        innovation[1] = ay;
        innovation[2] = az;
        innovation[3] = mx;  // ìë ¥ê³„ ì¸¡ì •ê°’
        innovation[4] = my;
        innovation[5] = mz;
        
        // ì¹¼ë§Œ ê²Œì¸ ê³„ì‚° (ê°„ë‹¨í™”ëœ ë²„ì „)
        float K[STATE_SIZE][MEASUREMENT_SIZE];
        for (int i = 0; i < STATE_SIZE; i++) {
            for (int j = 0; j < MEASUREMENT_SIZE; j++) {
                if (i == j && i < 3) {
                    K[i][j] = P[i][i] / (P[i][i] + R[j][j]);
                } else {
                    K[i][j] = 0.0f;
                }
            }
        }
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸ (ê°„ë‹¨í™”)
        state[0] += K[0][0] * (measured_roll - state[0]);
        state[1] += K[1][1] * (measured_pitch - state[1]);
        
        // ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
        for (int i = 0; i < 3; i++) {
            P[i][i] = (1.0f - K[i][i]) * P[i][i];
        }
    }
    
    float getRoll() const { return state[0] * RAD_TO_DEG; }
    float getPitch() const { return state[1] * RAD_TO_DEG; }
    float getYaw() const { return state[2] * RAD_TO_DEG; }
    
    void getRollPitchYaw(float& roll, float& pitch, float& yaw) const {
        roll = state[0] * RAD_TO_DEG;
        pitch = state[1] * RAD_TO_DEG;
        yaw = state[2] * RAD_TO_DEG;
    }
    
    void getGyroBias(float& bias_x, float& bias_y, float& bias_z) const {
        bias_x = state[3] * RAD_TO_DEG;
        bias_y = state[4] * RAD_TO_DEG;
        bias_z = state[5] * RAD_TO_DEG;
    }
    
private:
    float normalizeAngle(float angle) {
        while (angle > PI) angle -= 2.0f * PI;
        while (angle < -PI) angle += 2.0f * PI;
        return angle;
    }
};
```

### **3.3 ì„¼ì„œ ìœµí•© ì‹œìŠ¤í…œ í†µí•©**

#### **ë‹¤ì¤‘ í•„í„° ë¹„êµ ì‹œìŠ¤í…œ**
```cpp
/*
 * ìƒë³´ í•„í„° vs ì¹¼ë§Œ í•„í„° ë¹„êµ ì‹œìŠ¤í…œ
 * ì‹¤ì‹œê°„ìœ¼ë¡œ ë‘ í•„í„°ì˜ ì„±ëŠ¥ì„ ë¹„êµ
 */

#include <Arduino.h>
#include <MPU9250.h>

MPU9250 mpu;
AttitudeEstimator complementaryFilter;
ExtendedKalmanFilter kalmanFilter;

struct FilterComparison {
    float comp_roll, comp_pitch, comp_yaw;
    float kf_roll, kf_pitch, kf_yaw;
    float raw_roll, raw_pitch, raw_yaw;
    unsigned long timestamp;
};

FilterComparison comparison;

void setup() {
    Serial.begin(115200);
    
    // MPU9250 ì´ˆê¸°í™”
    Wire.begin(4, 5);
    if (!mpu.setup(0x68)) {
        Serial.println("MPU9250 ì´ˆê¸°í™” ì‹¤íŒ¨!");
        return;
    }
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜
    Serial.println("ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì¤‘...");
    mpu.calibrateAccelGyro();
    mpu.calibrateMag();
    
    // í•„í„° ì´ˆê¸°í™”
    complementaryFilter.reset();
    
    Serial.println("\ní•„í„° ë¹„êµ ì‹œìŠ¤í…œ ì‹œì‘");
    Serial.println("ì‹œê°„(ms)\tìƒë³´í•„í„°(Â°)\t\tì¹¼ë§Œí•„í„°(Â°)\t\tì›ì‹œë°ì´í„°(Â°)");
    Serial.println("\t\tR\tP\tY\tR\tP\tY\tR\tP\tY");
    Serial.println("-".repeat(80));
}

void loop() {
    if (mpu.update()) {
        // ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        float ax = mpu.getAccX();
        float ay = mpu.getAccY();
        float az = mpu.getAccZ();
        float gx = mpu.getGyroX();
        float gy = mpu.getGyroY();
        float gz = mpu.getGyroZ();
        float mx = mpu.getMagX();
        float my = mpu.getMagY();
        float mz = mpu.getMagZ();
        
        // ì›ì‹œ ê°ë„ ê³„ì‚° (ê°€ì†ë„ê³„ë§Œ ì‚¬ìš©)
        comparison.raw_roll = atan2(ay, az) * RAD_TO_DEG;
        comparison.raw_pitch = atan2(-ax, sqrt(ay*ay + az*az)) * RAD_TO_DEG;
        comparison.raw_yaw = atan2(-my, mx) * RAD_TO_DEG;
        
        // ìƒë³´ í•„í„° ì—…ë°ì´íŠ¸
        complementaryFilter.update(ax, ay, az, gx, gy, gz, mx, my, mz);
        comparison.comp_roll = complementaryFilter.getRoll();
        comparison.comp_pitch = complementaryFilter.getPitch();
        comparison.comp_yaw = complementaryFilter.getYaw();
        
        // ì¹¼ë§Œ í•„í„° ì—…ë°ì´íŠ¸
        static unsigned long lastTime = micros();
        unsigned long now = micros();
        float dt = (now - lastTime) / 1000000.0f;
        lastTime = now;
        
        kalmanFilter.predict(gx * DEG_TO_RAD, gy * DEG_TO_RAD, gz * DEG_TO_RAD, dt);
        kalmanFilter.update(ax, ay, az, mx, my, mz);
        comparison.kf_roll = kalmanFilter.getRoll();
        comparison.kf_pitch = kalmanFilter.getPitch();
        comparison.kf_yaw = kalmanFilter.getYaw();
        
        comparison.timestamp = millis();
        
        // ê²°ê³¼ ì¶œë ¥ (10Hz)
        static unsigned long lastPrint = 0;
        if (millis() - lastPrint >= 100) {
            printComparison();
            lastPrint = millis();
        }
    }
    
    delayMicroseconds(500);  // 2000Hz ìƒ˜í”Œë§
}

void printComparison() {
    Serial.printf("%lu\t", comparison.timestamp);
    
    // ìƒë³´ í•„í„°
    Serial.printf("%.1f\t%.1f\t%.1f\t", 
                 comparison.comp_roll, 
                 comparison.comp_pitch, 
                 comparison.comp_yaw);
    
    // ì¹¼ë§Œ í•„í„°  
    Serial.printf("%.1f\t%.1f\t%.1f\t", 
                 comparison.kf_roll, 
                 comparison.kf_pitch, 
                 comparison.kf_yaw);
    
    // ì›ì‹œ ë°ì´í„°
    Serial.printf("%.1f\t%.1f\t%.1f\n", 
                 comparison.raw_roll, 
                 comparison.raw_pitch, 
                 comparison.raw_yaw);
}
```

---

ğŸ¯ 4.1 ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œìŠ¤í…œ
4.1.1 ì™„ì „ ìë™ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë„êµ¬
ìƒˆ í”„ë¡œì íŠ¸: "ESP32_Advanced_Calibration"

platformio.ini ì„¤ì •:
```
[env:arduino_nano_esp32_calib]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

monitor_speed = 115200
monitor_filters = esp32_exception_decoder

lib_deps = 
    hideakitai/MPU9250@^0.4.7
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1

build_flags = 
    -DCORE_DEBUG_LEVEL=3
    -DARDUINO_USB_CDC_ON_BOOT=1
```

ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë©”ì¸ ì½”ë“œ
cpp
/*
 * ESP32 MPU9250 ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œìŠ¤í…œ - ì™„ì„± ì½”ë“œ
 * ì›¹ ê¸°ë°˜ GUI + ìë™ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ + EEPROM ì €ì¥
 */

#include <Arduino.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <MPU9250.h>
#include <EEPROM.h>
#include <math.h>

// í•˜ë“œì›¨ì–´ ì„¤ì •
#define I2C_SDA 4
#define I2C_SCL 5
#define LED_PIN 2
#define BUZZER_PIN 13

// EEPROM ì„¤ì •
#define EEPROM_SIZE 512
#define CALIB_MAGIC 0xCAFEBABE
#define CALIB_ADDR 0

// WiFi ì„¤ì •
const char* ssid = "ESP32_Calibration";
const char* password = "calib2024";

// ê°ì²´ ì´ˆê¸°í™”
MPU9250 mpu;
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„° êµ¬ì¡°ì²´ (ë¬¸ì„œì—ì„œ ì •ì˜ëœ ê²ƒê³¼ ë™ì¼)
struct CalibrationData {
    uint32_t magic = CALIB_MAGIC;
    
    struct {
        float offset[3] = {0, 0, 0};
        float scale[3] = {1, 1, 1};
        bool completed = false;
        float quality = 0.0f;
    } accel;
    
    struct {
        float offset[3] = {0, 0, 0};
        float noise[3] = {0, 0, 0};
        bool completed = false;
        float quality = 0.0f;
    } gyro;
    
    struct {
        float offset[3] = {0, 0, 0};
        float scale[3] = {1, 1, 1};
        float rotation[9] = {1,0,0, 0,1,0, 0,0,1};
        bool completed = false;
        float quality = 0.0f;
    } mag;
    
    float overallQuality = 0.0f;
    unsigned long timestamp = 0;
};

CalibrationData calibData;

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìƒíƒœ ê´€ë¦¬
enum CalibState {
    CALIB_IDLE,
    CALIB_ACCEL_RUNNING,
    CALIB_GYRO_RUNNING,
    CALIB_MAG_RUNNING,
    CALIB_COMPLETE,
    CALIB_ERROR
};

struct CalibrationStatus {
    CalibState state = CALIB_IDLE;
    int progress = 0;
    String message = "ëŒ€ê¸° ì¤‘";
    String instruction = "";
    bool userAction = false;
    unsigned long startTime = 0;
    int currentStep = 0;
    int totalSteps = 0;
};

CalibrationStatus calibStatus;

// í•¨ìˆ˜ ì„ ì–¸
void loadCalibrationData();
void saveCalibrationData();
void blinkError();
void playStartupTone();
void playSuccessTone();
void updateStatusLED();
void sendSensorData();
void sendCalibrationStatus();
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len);
void setupWebServer();
const char* getCalibrationHTML();

// API í•¸ë“¤ëŸ¬ ì„ ì–¸
void handleStartAccelCalib(AsyncWebServerRequest *request);
void handleStartGyroCalib(AsyncWebServerRequest *request);
void handleStartMagCalib(AsyncWebServerRequest *request);
void handleStopCalib(AsyncWebServerRequest *request);
void handleSaveCalib(AsyncWebServerRequest *request);
void handleLoadCalib(AsyncWebServerRequest *request);
void handleResetCalib(AsyncWebServerRequest *request);
void handleGetStatus(AsyncWebServerRequest *request);

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n========================================");
    Serial.println("ğŸ”§ ESP32 MPU9250 ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œìŠ¤í…œ");
    Serial.println("========================================");
    
    // GPIO ì´ˆê¸°í™”
    pinMode(LED_PIN, OUTPUT);
    pinMode(BUZZER_PIN, OUTPUT);
    
    // EEPROM ì´ˆê¸°í™”
    EEPROM.begin(EEPROM_SIZE);
    loadCalibrationData();
    
    // I2C ë° MPU9250 ì´ˆê¸°í™”
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(400000);
    
    if (!mpu.setup(0x68)) {
        Serial.println("âŒ MPU9250 ì´ˆê¸°í™” ì‹¤íŒ¨!");
        while (1) {
            blinkError();
            delay(1000);
        }
    }
    
    Serial.println("âœ… MPU9250 ì´ˆê¸°í™” ì„±ê³µ");
    
    // WiFi AP ì‹œì‘
    WiFi.softAP(ssid, password);
    IPAddress IP = WiFi.softAPIP();
    
    Serial.printf("ğŸ“¡ WiFi AP ì‹œì‘: %s\n", ssid);
    Serial.printf("ğŸŒ ì›¹ ì£¼ì†Œ: http://%s\n", IP.toString().c_str());
    
    // ì›¹ ì„œë²„ ì„¤ì •
    setupWebServer();
    
    Serial.println("âœ… ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!");
    Serial.println("ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ì§„í–‰í•˜ì„¸ìš”.\n");
    
    playStartupTone();
}

void loop() {
    if (mpu.update()) {
        if (calibStatus.state != CALIB_IDLE && calibStatus.state != CALIB_COMPLETE) {
            processCalibration();
        }
        
        static unsigned long lastSend = 0;
        if (millis() - lastSend >= 100) {
            sendSensorData();
            lastSend = millis();
        }
    }
    
    updateStatusLED();
    delay(1);
}

// EEPROM ë°ì´í„° ë¡œë“œ
void loadCalibrationData() {
    CalibrationData tempData;
    EEPROM.get(CALIB_ADDR, tempData);
    
    if (tempData.magic == CALIB_MAGIC) {
        calibData = tempData;
        Serial.printf("âœ… EEPROMì—ì„œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„° ë¡œë“œ (í’ˆì§ˆ: %.1f%%)\n", 
                     calibData.overallQuality);
    } else {
        Serial.println("âš ï¸  EEPROMì— ìœ íš¨í•œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„° ì—†ìŒ");
        calibData = CalibrationData(); // ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
    }
}

// EEPROM ë°ì´í„° ì €ì¥ (ë¬¸ì„œì—ì„œ ì‹œì‘ëœ í•¨ìˆ˜ ì™„ì„±)
void saveCalibrationData() {
    calibData.timestamp = millis();
    
    // ì „ì²´ í’ˆì§ˆ ê³„ì‚°
    int completedSensors = 0;
    float totalQuality = 0;
    
    if (calibData.accel.completed) {
        totalQuality += calibData.accel.quality;
        completedSensors++;
    }
    if (calibData.gyro.completed) {
        totalQuality += calibData.gyro.quality;
        completedSensors++;
    }
    if (calibData.mag.completed) {
        totalQuality += calibData.mag.quality;
        completedSensors++;
    }
    
    calibData.overallQuality = (completedSensors > 0) ? (totalQuality / completedSensors) : 0;
    
    // EEPROMì— ì €ì¥
    EEPROM.put(CALIB_ADDR, calibData);
    EEPROM.commit();
    
    Serial.printf("âœ… ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„° EEPROMì— ì €ì¥ ì™„ë£Œ (í’ˆì§ˆ: %.1f%%)\n", 
                 calibData.overallQuality);
}

// í•˜ë“œì›¨ì–´ ì œì–´ í•¨ìˆ˜ë“¤
void blinkError() {
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_PIN, HIGH);
        delay(100);
        digitalWrite(LED_PIN, LOW);
        delay(100);
    }
}

void playStartupTone() {
    tone(BUZZER_PIN, 1000, 200);
    delay(250);
    tone(BUZZER_PIN, 1500, 200);
    delay(250);
    tone(BUZZER_PIN, 2000, 300);
}

void playSuccessTone() {
    tone(BUZZER_PIN, 1500, 100);
    delay(150);
    tone(BUZZER_PIN, 2000, 100);
}

void updateStatusLED() {
    static unsigned long lastBlink = 0;
    static bool ledState = false;
    
    switch (calibStatus.state) {
        case CALIB_IDLE:
            digitalWrite(LED_PIN, millis() % 2000 < 100); // 2ì´ˆë§ˆë‹¤ ì§§ì€ ê¹œë°•ì„
            break;
        case CALIB_ACCEL_RUNNING:
        case CALIB_GYRO_RUNNING:
        case CALIB_MAG_RUNNING:
            if (millis() - lastBlink > 200) { // ë¹ ë¥¸ ê¹œë°•ì„
                ledState = !ledState;
                digitalWrite(LED_PIN, ledState);
                lastBlink = millis();
            }
            break;
        case CALIB_COMPLETE:
            digitalWrite(LED_PIN, HIGH); // ê³„ì† ì¼œì§
            break;
        case CALIB_ERROR:
            if (millis() - lastBlink > 500) { // ëŠë¦° ê¹œë°•ì„
                ledState = !ledState;
                digitalWrite(LED_PIN, ledState);
                lastBlink = millis();
            }
            break;
    }
}

// ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, 
                      AwsEventType type, void *arg, uint8_t *data, size_t len) {
    if (type == WS_EVT_CONNECT) {
        Serial.printf("ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: %u\n", client->id());
        sendCalibrationStatus(); // ì—°ê²°ì‹œ í˜„ì¬ ìƒíƒœ ì „ì†¡
    } else if (type == WS_EVT_DISCONNECT) {
        Serial.printf("ì›¹ì†Œì¼“ í´ë¼ì´ì–¸íŠ¸ í•´ì œ: %u\n", client->id());
    }
}

// ì„¼ì„œ ë°ì´í„° ì „ì†¡
void sendSensorData() {
    StaticJsonDocument<512> doc;
    
    doc["type"] = "sensorData";
    doc["timestamp"] = millis();
    doc["accel"]["x"] = mpu.getAccX();
    doc["accel"]["y"] = mpu.getAccY();
    doc["accel"]["z"] = mpu.getAccZ();
    doc["gyro"]["x"] = mpu.getGyroX();
    doc["gyro"]["y"] = mpu.getGyroY();
    doc["gyro"]["z"] = mpu.getGyroZ();
    doc["mag"]["x"] = mpu.getMagX();
    doc["mag"]["y"] = mpu.getMagY();
    doc["mag"]["z"] = mpu.getMagZ();
    doc["temp"] = mpu.getTemperature();
    
    String jsonString;
    serializeJson(doc, jsonString);
    ws.textAll(jsonString);
}

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìƒíƒœ ì „ì†¡
void sendCalibrationStatus() {
    StaticJsonDocument<1024> doc;
    
    doc["type"] = "calibStatus";
    doc["state"] = (int)calibStatus.state;
    doc["progress"] = calibStatus.progress;
    doc["message"] = calibStatus.message;
    doc["instruction"] = calibStatus.instruction;
    doc["userAction"] = calibStatus.userAction;
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„° ìƒíƒœ
    doc["accel"]["completed"] = calibData.accel.completed;
    doc["accel"]["quality"] = calibData.accel.quality;
    doc["gyro"]["completed"] = calibData.gyro.completed;
    doc["gyro"]["quality"] = calibData.gyro.quality;
    doc["mag"]["completed"] = calibData.mag.completed;
    doc["mag"]["quality"] = calibData.mag.quality;
    doc["overallQuality"] = calibData.overallQuality;
    
    String jsonString;
    serializeJson(doc, jsonString);
    ws.textAll(jsonString);
}

// ì›¹ ì„œë²„ ì„¤ì • (ë¬¸ì„œì—ì„œ ì‹œì‘ëœ í•¨ìˆ˜ ì™„ì„±)
void setupWebServer() {
    ws.onEvent(onWebSocketEvent);
    server.addHandler(&ws);
    
    // ë©”ì¸ í˜ì´ì§€
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send_P(200, "text/html", getCalibrationHTML());
    });
    
    // API ì—”ë“œí¬ì¸íŠ¸ë“¤
    server.on("/api/start-accel", HTTP_POST, handleStartAccelCalib);
    server.on("/api/start-gyro", HTTP_POST, handleStartGyroCalib);
    server.on("/api/start-mag", HTTP_POST, handleStartMagCalib);
    server.on("/api/stop", HTTP_POST, handleStopCalib);
    server.on("/api/save", HTTP_POST, handleSaveCalib);
    server.on("/api/load", HTTP_POST, handleLoadCalib);
    server.on("/api/reset", HTTP_POST, handleResetCalib);
    server.on("/api/status", HTTP_GET, handleGetStatus);
    
    server.begin();
    Serial.println("ğŸŒ ì›¹ ì„œë²„ ì‹œì‘ ì™„ë£Œ");
}

// API í•¸ë“¤ëŸ¬ êµ¬í˜„
void handleStartAccelCalib(AsyncWebServerRequest *request) {
    if (calibStatus.state == CALIB_IDLE) {
        startAccelCalibration();
        request->send(200, "application/json", "{\"success\":true}");
    } else {
        request->send(400, "application/json", "{\"success\":false,\"error\":\"ì´ë¯¸ ì‹¤í–‰ ì¤‘\"}");
    }
}

void handleStartGyroCalib(AsyncWebServerRequest *request) {
    if (calibStatus.state == CALIB_IDLE) {
        startGyroCalibration();
        request->send(200, "application/json", "{\"success\":true}");
    } else {
        request->send(400, "application/json", "{\"success\":false,\"error\":\"ì´ë¯¸ ì‹¤í–‰ ì¤‘\"}");
    }
}

void handleStartMagCalib(AsyncWebServerRequest *request) {
    if (calibStatus.state == CALIB_IDLE) {
        startMagCalibration();
        request->send(200, "application/json", "{\"success\":true}");
    } else {
        request->send(400, "application/json", "{\"success\":false,\"error\":\"ì´ë¯¸ ì‹¤í–‰ ì¤‘\"}");
    }
}

void handleStopCalib(AsyncWebServerRequest *request) {
    calibStatus.state = CALIB_IDLE;
    calibStatus.message = "ì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë¨";
    sendCalibrationStatus();
    request->send(200, "application/json", "{\"success\":true}");
}

void handleSaveCalib(AsyncWebServerRequest *request) {
    saveCalibrationData();
    request->send(200, "application/json", "{\"success\":true}");
}

void handleLoadCalib(AsyncWebServerRequest *request) {
    loadCalibrationData();
    sendCalibrationStatus();
    request->send(200, "application/json", "{\"success\":true}");
}

void handleResetCalib(AsyncWebServerRequest *request) {
    calibData = CalibrationData();
    saveCalibrationData();
    sendCalibrationStatus();
    request->send(200, "application/json", "{\"success\":true}");
}

void handleGetStatus(AsyncWebServerRequest *request) {
    StaticJsonDocument<512> doc;
    doc["state"] = (int)calibStatus.state;
    doc["progress"] = calibStatus.progress;
    doc["message"] = calibStatus.message;
    doc["overallQuality"] = calibData.overallQuality;
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
}

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í”„ë¡œì„¸ìŠ¤ í•¨ìˆ˜ë“¤ (ë¬¸ì„œì˜ í•¨ìˆ˜ë“¤ì„ ì—¬ê¸°ì— í¬í•¨)
void processCalibration() {
    switch (calibStatus.state) {
        case CALIB_ACCEL_RUNNING:
            processAccelCalibration();
            break;
        case CALIB_GYRO_RUNNING:
            processGyroCalibration();
            break;
        case CALIB_MAG_RUNNING:
            processMagCalibration();
            break;
    }
}

// HTML í˜ì´ì§€
const char* getCalibrationHTML() {
    return R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>ESP32 MPU9250 ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f0f2f5;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .content { 
            padding: 30px; 
        }
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .sensor-card {
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9fa;
        }
        .sensor-card.completed {
            border-color: #28a745;
            background: #d4edda;
        }
        .quality-bar {
            width: 100%;
            height: 10px;
            background: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ffc107 50%, #28a745 100%);
            transition: width 0.3s;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s;
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .progress-container {
            background: #e9ecef;
            border-radius: 10px;
            height: 20px;
            margin: 20px 0;
            overflow: hidden;
        }
        .progress-bar {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .status-panel {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .real-time-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .data-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .data-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #495057;
        }
        .data-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }
        .connected { color: #28a745; }
        .disconnected { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”§ ESP32 MPU9250 ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜</h1>
            <p>ì •ë°€í•œ ì„¼ì„œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìœ¼ë¡œ ìµœì ì˜ ì„±ëŠ¥ì„ ë‹¬ì„±í•˜ì„¸ìš”</p>
        </div>
        
        <div class="content">
            <div id="connection-status" class="disconnected">ì—°ê²° ì¤‘...</div>
            
            <div class="sensor-grid">
                <div class="sensor-card" id="accel-card">
                    <h3>ğŸƒâ€â™‚ï¸ ê°€ì†ë„ê³„</h3>
                    <p>6ë©´ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìœ¼ë¡œ ì •í™•í•œ ì¤‘ë ¥ ë²¡í„° ì¸¡ì •</p>
                    <div class="quality-bar">
                        <div class="quality-fill" id="accel-quality" style="width: 0%"></div>
                    </div>
                    <p>í’ˆì§ˆ: <span id="accel-quality-text">0%</span></p>
                    <button class="btn btn-primary" onclick="startAccelCalib()">ì‹œì‘</button>
                </div>
                
                <div class="sensor-card" id="gyro-card">
                    <h3>ğŸŒ€ ìì´ë¡œìŠ¤ì½”í”„</h3>
                    <p>ë°”ì´ì–´ìŠ¤ ë° ë…¸ì´ì¦ˆ ë¶„ì„ìœ¼ë¡œ ì•ˆì •ì ì¸ ê°ì†ë„ ì¸¡ì •</p>
                    <div class="quality-bar">
                        <div class="quality-fill" id="gyro-quality" style="width: 0%"></div>
                    </div>
                    <p>í’ˆì§ˆ: <span id="gyro-quality-text">0%</span></p>
                    <button class="btn btn-primary" onclick="startGyroCalib()">ì‹œì‘</button>
                </div>
                
                <div class="sensor-card" id="mag-card">
                    <h3>ğŸ§­ ìë ¥ê³„</h3>
                    <p>í•˜ë“œ/ì†Œí”„íŠ¸ ì•„ì´ì–¸ ë³´ì •ìœ¼ë¡œ ì •í™•í•œ ë°©í–¥ ê°ì§€</p>
                    <div class="quality-bar">
                        <div class="quality-fill" id="mag-quality" style="width: 0%"></div>
                    </div>
                    <p>í’ˆì§ˆ: <span id="mag-quality-text">0%</span></p>
                    <button class="btn btn-primary" onclick="startMagCalib()">ì‹œì‘</button>
                </div>
            </div>
            
            <div class="status-panel">
                <h3>ğŸ“Š ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìƒíƒœ</h3>
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar" style="width: 0%">0%</div>
                </div>
                <p><strong>ìƒíƒœ:</strong> <span id="status-message">ëŒ€ê¸° ì¤‘</span></p>
                <p><strong>ì§€ì‹œì‚¬í•­:</strong> <span id="instruction">ìº˜ë¦¬ë¸Œë ˆì´ì…˜í•  ì„¼ì„œë¥¼ ì„ íƒí•˜ì„¸ìš”</span></p>
                <p><strong>ì „ì²´ í’ˆì§ˆ:</strong> <span id="overall-quality">0%</span></p>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="btn btn-danger" onclick="stopCalib()">ì¤‘ë‹¨</button>
                <button class="btn btn-success" onclick="saveCalib()">ì €ì¥</button>
                <button class="btn btn-warning" onclick="loadCalib()">ë¶ˆëŸ¬ì˜¤ê¸°</button>
                <button class="btn btn-secondary" onclick="resetCalib()">ì´ˆê¸°í™”</button>
            </div>
            
            <h3>ğŸ“¡ ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„°</h3>
            <div class="real-time-data">
                <div class="data-item">
                    <div class="data-value" id="accel-x">0.00</div>
                    <div class="data-label">ê°€ì†ë„ X (g)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="accel-y">0.00</div>
                    <div class="data-label">ê°€ì†ë„ Y (g)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="accel-z">0.00</div>
                    <div class="data-label">ê°€ì†ë„ Z (g)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="gyro-x">0.0</div>
                    <div class="data-label">ìì´ë¡œ X (Â°/s)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="gyro-y">0.0</div>
                    <div class="data-label">ìì´ë¡œ Y (Â°/s)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="gyro-z">0.0</div>
                    <div class="data-label">ìì´ë¡œ Z (Â°/s)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="mag-x">0</div>
                    <div class="data-label">ìë ¥ X (Î¼T)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="mag-y">0</div>
                    <div class="data-label">ìë ¥ Y (Î¼T)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="mag-z">0</div>
                    <div class="data-label">ìë ¥ Z (Î¼T)</div>
                </div>
                <div class="data-item">
                    <div class="data-value" id="temp">0.0</div>
                    <div class="data-label">ì˜¨ë„ (Â°C)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const ws = new WebSocket('ws://' + window.location.host + '/ws');
        const status = document.getElementById('connection-status');
        
        ws.onopen = function() {
            status.textContent = 'âœ… ì—°ê²°ë¨';
            status.className = 'connected';
        };
        
        ws.onclose = function() {
            status.textContent = 'âŒ ì—°ê²° ëŠì–´ì§';
            status.className = 'disconnected';
        };
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'sensorData') {
                updateSensorData(data);
            } else if (data.type === 'calibStatus') {
                updateCalibStatus(data);
            }
        };
        
        function updateSensorData(data) {
            document.getElementById('accel-x').textContent = data.accel.x.toFixed(2);
            document.getElementById('accel-y').textContent = data.accel.y.toFixed(2);
            document.getElementById('accel-z').textContent = data.accel.z.toFixed(2);
            document.getElementById('gyro-x').textContent = data.gyro.x.toFixed(1);
            document.getElementById('gyro-y').textContent = data.gyro.y.toFixed(1);
            document.getElementById('gyro-z').textContent = data.gyro.z.toFixed(1);
            document.getElementById('mag-x').textContent = Math.round(data.mag.x);
            document.getElementById('mag-y').textContent = Math.round(data.mag.y);
            document.getElementById('mag-z').textContent = Math.round(data.mag.z);
            document.getElementById('temp').textContent = data.temp.toFixed(1);
        }
        
        function updateCalibStatus(data) {
            document.getElementById('progress-bar').style.width = data.progress + '%';
            document.getElementById('progress-bar').textContent = data.progress + '%';
            document.getElementById('status-message').textContent = data.message;
            document.getElementById('instruction').textContent = data.instruction;
            document.getElementById('overall-quality').textContent = data.overallQuality.toFixed(1) + '%';
            
            // ì„¼ì„œë³„ í’ˆì§ˆ ì—…ë°ì´íŠ¸
            updateSensorCard('accel', data.accel);
            updateSensorCard('gyro', data.gyro);
            updateSensorCard('mag', data.mag);
        }
        
        function updateSensorCard(sensor, sensorData) {
            const card = document.getElementById(sensor + '-card');
            const qualityFill = document.getElementById(sensor + '-quality');
            const qualityText = document.getElementById(sensor + '-quality-text');
            
            qualityFill.style.width = sensorData.quality + '%';
            qualityText.textContent = sensorData.quality.toFixed(1) + '%';
            
            if (sensorData.completed) {
                card.classList.add('completed');
            } else {
                card.classList.remove('completed');
            }
        }
        
        // API í˜¸ì¶œ í•¨ìˆ˜ë“¤
        async function startAccelCalib() {
            try {
                const response = await fetch('/api/start-accel', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert('ì˜¤ë¥˜: ' + result.error);
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function startGyroCalib() {
            try {
                const response = await fetch('/api/start-gyro', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert('ì˜¤ë¥˜: ' + result.error);
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function startMagCalib() {
            try {
                const response = await fetch('/api/start-mag', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert('ì˜¤ë¥˜: ' + result.error);
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function stopCalib() {
            try {
                const response = await fetch('/api/stop', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    alert('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function saveCalib() {
            try {
                const response = await fetch('/api/save', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    alert('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function loadCalib() {
            try {
                const response = await fetch('/api/load', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    alert('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        async function resetCalib() {
            if (confirm('ëª¨ë“  ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                try {
                    const response = await fetch('/api/reset', { method: 'POST' });
                    const result = await response.json();
                    if (result.success) {
                        alert('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                } catch (error) {
                    alert('í†µì‹  ì˜¤ë¥˜: ' + error.message);
                }
            }
        }
    </script>
</body>
</html>
)rawliteral";
}

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘ í•¨ìˆ˜ë“¤ (ë¬¸ì„œì—ì„œ ì •ì˜ëœ ê²ƒë“¤ì„ ì¶”ê°€)
void startAccelCalibration() {
    Serial.println("ğŸ”§ ê°€ì†ë„ê³„ ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘");
    
    calibStatus.state = CALIB_ACCEL_RUNNING;
    calibStatus.progress = 0;
    calibStatus.currentStep = 0;
    calibStatus.totalSteps = 6;
    calibStatus.startTime = millis();
    calibStatus.message = "ê°€ì†ë„ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì§„í–‰ ì¤‘";
    calibStatus.userAction = true;
    calibStatus.instruction = "ì„¼ì„œë¥¼ í‰í‰í•œ ê³³ì— ë†“ê³  5ì´ˆê°„ ê¸°ë‹¤ë¦¬ì„¸ìš” (1/6 - ìƒë©´)";
    
    sendCalibrationStatus();
}

void startGyroCalibration() {
    Serial.println("ğŸ”§ ìì´ë¡œìŠ¤ì½”í”„ ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘");
    
    calibStatus.state = CALIB_GYRO_RUNNING;
    calibStatus.progress = 0;
    calibStatus.currentStep = 0;
    calibStatus.totalSteps = 1;
    calibStatus.startTime = millis();
    calibStatus.message = "ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì§„í–‰ ì¤‘";
    calibStatus.userAction = true;
    calibStatus.instruction = "ì„¼ì„œë¥¼ ì™„ì „íˆ ì •ì§€ì‹œí‚¤ê³  ì§„ë™ì´ ì—†ëŠ” ê³³ì— ë†“ìœ¼ì„¸ìš”";
    
    sendCalibrationStatus();
}

void startMagCalibration() {
    Serial.println("ğŸ”§ ìë ¥ê³„ ê³ ê¸‰ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘");
    
    calibStatus.state = CALIB_MAG_RUNNING;
    calibStatus.progress = 0;
    calibStatus.currentStep = 0;
    calibStatus.totalSteps = 30;
    calibStatus.startTime = millis();
    calibStatus.message = "ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì§„í–‰ ì¤‘";
    calibStatus.userAction = true;
    calibStatus.instruction = "ì„¼ì„œë¥¼ ëª¨ë“  ë°©í–¥ìœ¼ë¡œ ì²œì²œíˆ íšŒì „ì‹œí‚¤ì„¸ìš” (8ì ëª¨ì–‘)";
    
    sendCalibrationStatus();
}

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì²˜ë¦¬ í•¨ìˆ˜ë“¤ (ë¬¸ì„œì— ì •ì˜ëœ í•¨ìˆ˜ë“¤ì„ ì°¸ì¡°í•˜ì—¬ êµ¬í˜„)
void processAccelCalibration() {
    static float samples[6][3];
    static int sampleCount = 0;
    static unsigned long stepStartTime = 0;
    static float sum[3] = {0};
    static int readings = 0;
    
    const char* faceNames[] = {"ìƒë©´(Z+)", "í•˜ë©´(Z-)", "ìš°ì¸¡(Y+)", "ì¢Œì¸¡(Y-)", "ì•ë©´(X+)", "ë’·ë©´(X-)"};
    
    if (stepStartTime == 0) {
        stepStartTime = millis();
        sum[0] = sum[1] = sum[2] = 0;
        readings = 0;
        calibStatus.instruction = "ì„¼ì„œë¥¼ " + String(faceNames[calibStatus.currentStep]) + 
                                 "ì— ë†“ê³  ì•ˆì •í™”ê¹Œì§€ ê¸°ë‹¤ë¦¬ì„¸ìš”";
        sendCalibrationStatus();
    }
    
    if (millis() - stepStartTime < 3000) {
        calibStatus.progress = (calibStatus.currentStep * 100 / 6) + 
                              ((millis() - stepStartTime) * 16 / 3000);
        return;
    }
    
    if (millis() - stepStartTime < 5000) {
        sum[0] += mpu.getAccX();
        sum[1] += mpu.getAccY();
        sum[2] += mpu.getAccZ();
        readings++;
        
        calibStatus.progress = (calibStatus.currentStep * 100 / 6) + 
                              (3 * 16 / 5) + ((millis() - stepStartTime - 3000) * 10 / 2000);
        
        if (readings % 50 == 0) {
            calibStatus.instruction = "ë°ì´í„° ìˆ˜ì§‘ ì¤‘... (" + String(readings) + " ìƒ˜í”Œ)";
            sendCalibrationStatus();
        }
        return;
    }
    
    if (readings > 0) {
        samples[calibStatus.currentStep][0] = sum[0] / readings;
        samples[calibStatus.currentStep][1] = sum[1] / readings;
        samples[calibStatus.currentStep][2] = sum[2] / readings;
        
        Serial.printf("ë©´ %d ì™„ë£Œ: %.3f, %.3f, %.3f (ìƒ˜í”Œ: %d)\n",
                     calibStatus.currentStep + 1,
                     samples[calibStatus.currentStep][0],
                     samples[calibStatus.currentStep][1], 
                     samples[calibStatus.currentStep][2],
                     readings);
        
        calibStatus.currentStep++;
        stepStartTime = 0;
        
        playSuccessTone();
        
        if (calibStatus.currentStep >= 6) {
            calculateAccelCalibration(samples);
            calibStatus.state = CALIB_COMPLETE;
            calibStatus.progress = 100;
            calibStatus.message = "ê°€ì†ë„ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!";
            calibStatus.instruction = "í’ˆì§ˆ: " + String(calibData.accel.quality, 1) + "%";
            calibData.accel.completed = true;
            
            Serial.println("âœ… ê°€ì†ë„ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ");
        } else {
            calibStatus.instruction = "ë‹¤ìŒ: " + String(faceNames[calibStatus.currentStep]) + 
                                     "ì— ì„¼ì„œë¥¼ ë†“ìœ¼ì„¸ìš”";
        }
        
        sendCalibrationStatus();
    }
}

void processGyroCalibration() {
    static float samples[3][2000];
    static int sampleCount = 0;
    static unsigned long startTime = 0;
    
    if (startTime == 0) {
        startTime = millis();
        sampleCount = 0;
        calibStatus.instruction = "ì¸¡ì • ì‹œì‘... ì ˆëŒ€ ì›€ì§ì´ì§€ ë§ˆì„¸ìš”!";
        sendCalibrationStatus();
    }
    
    if (millis() - startTime < 2000) {
        calibStatus.progress = (millis() - startTime) / 20;
        return;
    }
    
    if (sampleCount < 2000 && millis() - startTime < 12000) {
        samples[0][sampleCount] = mpu.getGyroX();
        samples[1][sampleCount] = mpu.getGyroY();
        samples[2][sampleCount] = mpu.getGyroZ();
        sampleCount++;
        
        calibStatus.progress = 10 + (sampleCount * 80 / 2000);
        
        if (sampleCount % 200 == 0) {
            calibStatus.instruction = "ë°ì´í„° ìˆ˜ì§‘ ì¤‘... " + String(sampleCount) + "/2000 ìƒ˜í”Œ";
            sendCalibrationStatus();
        }
        return;
    }
    
    if (sampleCount >= 2000) {
        calculateGyroCalibration(samples, sampleCount);
        calibStatus.state = CALIB_COMPLETE;
        calibStatus.progress = 100;
        calibStatus.message = "ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!";
        calibStatus.instruction = "í’ˆì§ˆ: " + String(calibData.gyro.quality, 1) + "%";
        calibData.gyro.completed = true;
        
        Serial.println("âœ… ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ");
        sendCalibrationStatus();
    }
}

void processMagCalibration() {
    static float samples[3][3000];
    static int sampleCount = 0;
    static unsigned long startTime = 0;
    
    if (startTime == 0) {
        startTime = millis();
        sampleCount = 0;
    }
    
    if (millis() - startTime < 3000) {
        calibStatus.progress = (millis() - startTime) / 30;
        calibStatus.instruction = "ì¤€ë¹„ ì¤‘... " + String(3 - (millis() - startTime) / 1000) + "ì´ˆ í›„ ì‹œì‘";
        sendCalibrationStatus();
        return;
    }
    
    if (sampleCount < 3000 && millis() - startTime < 33000) {
        float mx = mpu.getMagX();
        float my = mpu.getMagY();
        float mz = mpu.getMagZ();
        
        if (mx != 0 || my != 0 || mz != 0) {
            samples[0][sampleCount] = mx;
            samples[1][sampleCount] = my;
            samples[2][sampleCount] = mz;
            sampleCount++;
        }
        
        calibStatus.progress = 10 + ((millis() - startTime - 3000) * 80 / 30000);
        
        if ((millis() - startTime) % 3000 == 0) {
            int remainingTime = 33 - (millis() - startTime) / 1000;
            calibStatus.instruction = "íšŒì „ ì¤‘... ë‚¨ì€ ì‹œê°„: " + String(remainingTime) + "ì´ˆ";
            sendCalibrationStatus();
        }
        return;
    }
    
    if (sampleCount >= 100) {
        calculateMagCalibration(samples, sampleCount);
        calibStatus.state = CALIB_COMPLETE;
        calibStatus.progress = 100;
        calibStatus.message = "ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!";
        calibStatus.instruction = "í’ˆì§ˆ: " + String(calibData.mag.quality, 1) + "%";
        calibData.mag.completed = true;
        
        Serial.println("âœ… ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ");
        sendCalibrationStatus();
    } else {
        calibStatus.state = CALIB_ERROR;
        calibStatus.message = "ìë ¥ê³„ ë°ì´í„° ë¶€ì¡±!";
        calibStatus.instruction = "ìë ¥ê³„ ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”";
        sendCalibrationStatus();
    }
}

// ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê³„ì‚° í•¨ìˆ˜ë“¤ (ë¬¸ì„œì—ì„œ ì •ì˜ëœ í•¨ìˆ˜ë“¤ì„ ì™„ì„±)
void calculateAccelCalibration(float samples[6][3]) {
    float maxVals[3] = {samples[0][0], samples[0][1], samples[0][2]};
    float minVals[3] = {samples[0][0], samples[0][1], samples[0][2]};
    
    for (int face = 1; face < 6; face++) {
        for (int axis = 0; axis < 3; axis++) {
            if (samples[face][axis] > maxVals[axis]) {
                maxVals[axis] = samples[face][axis];
            }
            if (samples[face][axis] < minVals[axis]) {
                minVals[axis] = samples[face][axis];
            }
        }
    }
    
    for (int axis = 0; axis < 3; axis++) {
        calibData.accel.offset[axis] = (maxVals[axis] + minVals[axis]) / 2.0f;
        float range = maxVals[axis] - minVals[axis];
        calibData.accel.scale[axis] = (range > 0.1f) ? (2.0f / range) : 1.0f;
    }
    
    float qualityScore = 0;
    int validAxes = 0;
    
    for (int axis = 0; axis < 3; axis++) {
        float range = maxVals[axis] - minVals[axis];
        if (range > 0.5f && range < 2.5f) {
            float error = abs(range - 2.0f) / 2.0f;
            qualityScore += (1.0f - error) * 100;
            validAxes++;
        }
    }
    
    calibData.accel.quality = validAxes > 0 ? (qualityScore / validAxes) : 0;
    
    Serial.printf("ê°€ì†ë„ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼:\n");
    Serial.printf("ì˜¤í”„ì…‹: X=%.4f, Y=%.4f, Z=%.4f\n", 
                 calibData.accel.offset[0], calibData.accel.offset[1], calibData.accel.offset[2]);
    Serial.printf("ìŠ¤ì¼€ì¼: X=%.4f, Y=%.4f, Z=%.4f\n", 
                 calibData.accel.scale[0], calibData.accel.scale[1], calibData.accel.scale[2]);
    Serial.printf("í’ˆì§ˆ: %.1f%%\n", calibData.accel.quality);
}

void calculateGyroCalibration(float samples[][2000], int count) {
    float sum[3] = {0};
    for (int i = 0; i < count; i++) {
        sum[0] += samples[0][i];
        sum[1] += samples[1][i];
        sum[2] += samples[2][i];
    }
    
    for (int axis = 0; axis < 3; axis++) {
        calibData.gyro.offset[axis] = sum[axis] / count;
    }
    
    float variance[3] = {0};
    for (int i = 0; i < count; i++) {
        for (int axis = 0; axis < 3; axis++) {
            float diff = samples[axis][i] - calibData.gyro.offset[axis];
            variance[axis] += diff * diff;
        }
    }
    
    for (int axis = 0; axis < 3; axis++) {
        calibData.gyro.noise[axis] = sqrt(variance[axis] / (count - 1));
    }
    
    float avgNoise = (calibData.gyro.noise[0] + calibData.gyro.noise[1] + calibData.gyro.noise[2]) / 3.0f;
    calibData.gyro.quality = max(0.0f, 100.0f - avgNoise * 20);
    
    Serial.printf("ìì´ë¡œìŠ¤ì½”í”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼:\n");
    Serial.printf("ì˜¤í”„ì…‹: X=%.4f, Y=%.4f, Z=%.4f (Â°/s)\n", 
                 calibData.gyro.offset[0], calibData.gyro.offset[1], calibData.gyro.offset[2]);
    Serial.printf("ë…¸ì´ì¦ˆ: X=%.4f, Y=%.4f, Z=%.4f (Â°/s RMS)\n", 
                 calibData.gyro.noise[0], calibData.gyro.noise[1], calibData.gyro.noise[2]);
    Serial.printf("í’ˆì§ˆ: %.1f%%\n", calibData.gyro.quality);
}

void calculateMagCalibration(float samples[][3000], int count) {
    float minVals[3] = {samples[0][0], samples[1][0], samples[2][0]};
    float maxVals[3] = {samples[0][0], samples[1][0], samples[2][0]};
    
    for (int i = 1; i < count; i++) {
        for (int axis = 0; axis < 3; axis++) {
            if (samples[axis][i] < minVals[axis]) minVals[axis] = samples[axis][i];
            if (samples[axis][i] > maxVals[axis]) maxVals[axis] = samples[axis][i];
        }
    }
    
    for (int axis = 0; axis < 3; axis++) {
        calibData.mag.offset[axis] = (maxVals[axis] + minVals[axis]) / 2.0f;
    }
    
    float ranges[3];
    for (int axis = 0; axis < 3; axis++) {
        ranges[axis] = (maxVals[axis] - minVals[axis]) / 2.0f;
    }
    
    float avgRadius = (ranges[0] + ranges[1] + ranges[2]) / 3.0f;
    for (int axis = 0; axis < 3; axis++) {
        calibData.mag.scale[axis] = (ranges[axis] > 0) ? (avgRadius / ranges[axis]) : 1.0f;
    }
    
    float maxRange = max(max(ranges[0], ranges[1]), ranges[2]);
    float minRange = min(min(ranges[0], ranges[1]), ranges[2]);
    float sphericity = (maxRange > 0) ? (minRange / maxRange) : 0;
    
    calibData.mag.quality = sphericity * 100;
    
    Serial.printf("ìë ¥ê³„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼:\n");
    Serial.printf("ì˜¤í”„ì…‹: X=%.2f, Y=%.2f, Z=%.2f\n", 
                 calibData.mag.offset[0], calibData.mag.offset[1], calibData.mag.offset[2]);
    Serial.printf("ìŠ¤ì¼€ì¼: X=%.4f, Y=%.4f, Z=%.4f\n", 
                 calibData.mag.scale[0], calibData.mag.scale[1], calibData.mag.scale[2]);
    Serial.printf("êµ¬í˜•ë„: %.1f%% (í’ˆì§ˆ ì§€í‘œ)\n", calibData.mag.quality);
}
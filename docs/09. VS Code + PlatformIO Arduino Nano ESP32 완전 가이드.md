# ğŸš€ VS Code + PlatformIO Arduino Nano ESP32 ì™„ì „ ê°€ì´ë“œ

## ğŸ“‹ ëª©í‘œ: VS Code + PlatformIO í™˜ê²½ì—ì„œ ë“œë¡  ê°œë°œì„ ìœ„í•œ ESP32 êµ¬ì¶•

**ê°œë°œ í™˜ê²½**: Windows + VS Code + PlatformIO + Arduino Framework

---

## 1ï¸âƒ£ ê°œë°œ í™˜ê²½ êµ¬ì¶• (45ë¶„)

### **1.1 VS Code ì„¤ì¹˜**

#### **VS Code ë‹¤ìš´ë¡œë“œ ë° ì„¤ì¹˜**
```
1. ê³µì‹ ì‚¬ì´íŠ¸ ë°©ë¬¸: https://code.visualstudio.com/
2. "Download for Windows" í´ë¦­
3. ì„¤ì¹˜ íŒŒì¼ ì‹¤í–‰
4. ì„¤ì¹˜ ì˜µì…˜:
   âœ… Add "Open with Code" action to Windows Explorer file context menu
   âœ… Add "Open with Code" action to Windows Explorer directory context menu
   âœ… Register Code as an editor for supported file types
   âœ… Add to PATH (requires shell restart)
5. ì„¤ì¹˜ ì™„ë£Œ í›„ VS Code ì‹¤í–‰
```

### **1.2 PlatformIO IDE í™•ì¥ ì„¤ì¹˜**

#### **PlatformIO ì„¤ì¹˜ ê³¼ì •**
```
1. VS Code ì‹¤í–‰
2. ì™¼ìª½ ì‚¬ì´ë“œë°”ì˜ Extensions ì•„ì´ì½˜ í´ë¦­ (Ctrl+Shift+X)
3. ê²€ìƒ‰ì°½ì— "PlatformIO IDE" ì…ë ¥
4. "PlatformIO IDE" by PlatformIO ì„ íƒ
5. "Install" ë²„íŠ¼ í´ë¦­
6. ì„¤ì¹˜ ì™„ë£Œ í›„ VS Code ì¬ì‹œì‘
7. í•˜ë‹¨ ìƒíƒœí‘œì‹œì¤„ì— PlatformIO ì•„ì´ì½˜ í™•ì¸
```

#### **PlatformIO ì´ˆê¸° ì„¤ì •**
```
ì¬ì‹œì‘ í›„:
1. ì™¼ìª½ ì‚¬ì´ë“œë°”ì— PlatformIO ì•„ì´ì½˜ (ê°œë¯¸ ëª¨ì–‘) ìƒì„± í™•ì¸
2. PlatformIO ì•„ì´ì½˜ í´ë¦­
3. "PlatformIO Home" íƒ­ì´ ì—´ë¦¬ë©´ ì„±ê³µ!
4. ì²« ì‹¤í–‰ ì‹œ ì¶”ê°€ ë„êµ¬ ì„¤ì¹˜ ì§„í–‰ (5-10ë¶„ ì†Œìš”)
```

### **1.3 Arduino Framework ì„¤ì •**

#### **í”Œë«í¼ ë° ë³´ë“œ ì„¤ì •**
PlatformIOëŠ” ìë™ìœ¼ë¡œ ESP32 í”Œë«í¼ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
í”„ë¡œì íŠ¸ ìƒì„± ì‹œ ìë™ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œë©ë‹ˆë‹¤.

---

## 2ï¸âƒ£ ì²« ë²ˆì§¸ í”„ë¡œì íŠ¸ ìƒì„±

### **2.1 ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±**

#### **í”„ë¡œì íŠ¸ ìƒì„± ê³¼ì •**
```
1. VS Codeì—ì„œ PlatformIO ì•„ì´ì½˜ í´ë¦­
2. "Home" â†’ "New Project" í´ë¦­
3. í”„ë¡œì íŠ¸ ì„¤ì •:
   - Name: "ESP32_LED_Test"
   - Board: "Arduino Nano ESP32" ê²€ìƒ‰ í›„ ì„ íƒ
   - Framework: "Arduino" ì„ íƒ
   - Location: ê¸°ë³¸ê°’ ì‚¬ìš© (ë˜ëŠ” ì›í•˜ëŠ” í´ë” ì„ íƒ)
4. "Finish" í´ë¦­
5. í”„ë¡œì íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ ëŒ€ê¸° (3-5ë¶„)
```

#### **í”„ë¡œì íŠ¸ êµ¬ì¡° í™•ì¸**
```
ESP32_LED_Test/
â”œâ”€â”€ .pio/                 # PlatformIO ë¹Œë“œ íŒŒì¼
â”œâ”€â”€ .vscode/              # VS Code ì„¤ì •
â”œâ”€â”€ include/              # í—¤ë” íŒŒì¼
â”œâ”€â”€ lib/                  # ì‚¬ìš©ì ë¼ì´ë¸ŒëŸ¬ë¦¬
â”œâ”€â”€ src/                  # ë©”ì¸ ì†ŒìŠ¤ ì½”ë“œ
â”‚   â””â”€â”€ main.cpp         # ë©”ì¸ íŒŒì¼ (Arduinoì˜ .ino íŒŒì¼ê³¼ ë™ì¼)
â”œâ”€â”€ test/                # í…ŒìŠ¤íŠ¸ ì½”ë“œ
â””â”€â”€ platformio.ini       # í”„ë¡œì íŠ¸ ì„¤ì • íŒŒì¼
```

### **2.2 platformio.ini ì„¤ì •**

#### **ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìˆ˜ì •**
```
; PlatformIO Project Configuration File

[env:arduino_nano_esp32]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„° ì„¤ì •
monitor_speed = 115200
monitor_port = AUTO

; ì—…ë¡œë“œ ì„¤ì •
upload_speed = 921600

; ë¹Œë“œ í”Œë˜ê·¸ (í•„ìš”ì‹œ)
build_flags = 
    -DCORE_DEBUG_LEVEL=3
    -DARDUINO_USB_CDC_ON_BOOT=1

; ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ì¡´ì„±
lib_deps = 
    hideakitai/MPU9250@^0.4.7
    madhephaestus/ESP32Servo@^0.13.0
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    br3ttb/PID@^1.2.1
```

---

## 3ï¸âƒ£ í•˜ë“œì›¨ì–´ ì—°ê²° ë° ê¸°ë³¸ í…ŒìŠ¤íŠ¸

### **3.1 ì²« ë²ˆì§¸ í…ŒìŠ¤íŠ¸: LED ì ë©¸**

#### **í•˜ë“œì›¨ì–´ ì—°ê²°**
```
ì¤€ë¹„ë¬¼:
â€¢ Arduino Nano ESP32
â€¢ USB-C ì¼€ì´ë¸”
â€¢ ë¸Œë ˆë“œë³´ë“œ
â€¢ LED 1ê°œ
â€¢ 220Î© ì €í•­ 1ê°œ
â€¢ ì í¼ ì™€ì´ì–´

ì—°ê²° ë°©ë²•:
1. Arduino Nano ESP32ë¥¼ ë¸Œë ˆë“œë³´ë“œì— ì‚½ì…
2. D2 í•€ â†’ 220Î© ì €í•­ â†’ LED ê¸´ ë‹¤ë¦¬ (ì• ë…¸ë“œ)
3. LED ì§§ì€ ë‹¤ë¦¬ (ìºì†Œë“œ) â†’ GND
```

#### **ì½”ë“œ ì‘ì„± (src/main.cpp)**
```
/*
 * Arduino Nano ESP32 LED ì ë©¸ í…ŒìŠ¤íŠ¸ (ìˆ˜ì •ëœ ë²„ì „)
 * í™˜ê²½: VS Code + PlatformIO
 * ëª©ì : ê¸°ë³¸ í•˜ë“œì›¨ì–´ ë™ì‘ í™•ì¸
 */

#include <Arduino.h>  // PlatformIOì—ì„œëŠ” í•„ìˆ˜!

// í•€ ì •ì˜
const int LED_PIN = 2;

// ì „ì—­ ë³€ìˆ˜
unsigned long previousMillis = 0;
const long interval = 1000;  // 1ì´ˆ ê°„ê²©
bool ledState = false;

void setup() {
    // ì‹œë¦¬ì–¼ í†µì‹  ì´ˆê¸°í™”
    Serial.begin(115200);
    
    // ì‹œë¦¬ì–¼ í¬íŠ¸ ì¤€ë¹„ ëŒ€ê¸°
    while (!Serial && millis() < 5000) {
        delay(10);
    }
    
    // LED í•€ ì„¤ì •
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    
    // ì‹œì‘ ë©”ì‹œì§€
    Serial.println("====================================");
    Serial.println("Arduino Nano ESP32 LED í…ŒìŠ¤íŠ¸ ì‹œì‘");
    Serial.println("PlatformIO í™˜ê²½ì—ì„œ ì‹¤í–‰");
    Serial.println("====================================");
    
    // ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥
    Serial.printf("ì¹© ëª¨ë¸: %s\n", ESP.getChipModel());
    Serial.printf("ì¹© ë¦¬ë¹„ì „: %d\n", ESP.getChipRevision());
    Serial.printf("CPU ì£¼íŒŒìˆ˜: %d MHz\n", getCpuFrequencyMhz());
    Serial.printf("Flash í¬ê¸°: %d MB\n", ESP.getFlashChipSize() / 1024 / 1024);
    Serial.printf("ì—¬ìœ  ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
    Serial.println();
}

void loop() {
    unsigned long currentMillis = millis();
    
    // ë¹„ì°¨ë‹¨ LED ì œì–´ (millis() ì‚¬ìš©)
    if (currentMillis - previousMillis >= interval) {
        previousMillis = currentMillis;
        
        // LED ìƒíƒœ í† ê¸€
        ledState = !ledState;
        digitalWrite(LED_PIN, ledState);
        
        // ìƒíƒœ ì¶œë ¥
        Serial.printf("[%lu ms] LED %s\n", 
                     currentMillis, 
                     ledState ? "ON" : "OFF");
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì£¼ê¸°ì  ì¶œë ¥ (10ì´ˆë§ˆë‹¤)
        static int counter = 0;
        if (++counter >= 10) {
            counter = 0;
            Serial.printf("í˜„ì¬ ì—¬ìœ  ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
        }
    }
    
    // ë‹¤ë¥¸ ì‘ì—…ì„ ìœ„í•œ ì—¬ìœ  ì‹œê°„
    yield();
}
```

#### **ë¹Œë“œ ë° ì—…ë¡œë“œ**
```
1. Arduino Nano ESP32ë¥¼ USB-Cë¡œ PCì— ì—°ê²°
2. VS Code í•˜ë‹¨ ìƒíƒœí‘œì‹œì¤„ì—ì„œ:
   - í™˜ê²½ í™•ì¸: "arduino_nano_esp32" í‘œì‹œ
   - í¬íŠ¸ í™•ì¸: COM í¬íŠ¸ ìë™ ê°ì§€
3. ë¹Œë“œ: Ctrl+Alt+B (ë˜ëŠ” í•˜ë‹¨ âœ“ ì•„ì´ì½˜)
4. ì—…ë¡œë“œ: Ctrl+Alt+U (ë˜ëŠ” í•˜ë‹¨ â†’ ì•„ì´ì½˜)
5. ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„°: Ctrl+Alt+S (ë˜ëŠ” í•˜ë‹¨ ğŸ”Œ ì•„ì´ì½˜)
```

#### **ì˜ˆìƒ ê²°ê³¼**
```
ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„° ì¶œë ¥:
====================================
Arduino Nano ESP32 LED í…ŒìŠ¤íŠ¸ ì‹œì‘
PlatformIO í™˜ê²½ì—ì„œ ì‹¤í–‰
====================================
ì¹© ëª¨ë¸: ESP32-S3
ì¹© ë¦¬ë¹„ì „: 0
CPU ì£¼íŒŒìˆ˜: 240 MHz
Flash í¬ê¸°: 16 MB
ì—¬ìœ  ë©”ëª¨ë¦¬: 327680 bytes

[1000 ms] LED ON
[2000 ms] LED OFF
[3000 ms] LED ON
...
```

---

### **3.2 ë‘ ë²ˆì§¸ í…ŒìŠ¤íŠ¸: WiFi ì—°ê²°**

#### **ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±**
```
í”„ë¡œì íŠ¸ëª…: "ESP32_WiFi_Test"
ë™ì¼í•œ ì„¤ì •ìœ¼ë¡œ í”„ë¡œì íŠ¸ ìƒì„±
```

#### **ì½”ë“œ ì‘ì„± (src/main.cpp)**
```cpp
/*
 * Arduino Nano ESP32 WiFi ì—°ê²° í…ŒìŠ¤íŠ¸
 * í™˜ê²½: VS Code + PlatformIO
 */

#include <Arduino.h>
#include <WiFi.h>

// WiFi ì„¤ì • (ë³¸ì¸ì˜ ì •ë³´ë¡œ ë³€ê²½!)
const char* WIFI_SSID = "YOUR_WIFI_NAME";
const char* WIFI_PASSWORD = "YOUR_WIFI_PASSWORD";

// ì—°ê²° íƒ€ì„ì•„ì›ƒ (ë°€ë¦¬ì´ˆ)
const unsigned long WIFI_TIMEOUT = 20000;

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n====================================");
    Serial.println("Arduino Nano ESP32 WiFi í…ŒìŠ¤íŠ¸");
    Serial.println("PlatformIO í™˜ê²½ì—ì„œ ì‹¤í–‰");
    Serial.println("====================================");
    
    // WiFi ëª¨ë“ˆ ì •ë³´
    Serial.printf("WiFi MAC ì£¼ì†Œ: %s\n", WiFi.macAddress().c_str());
    
    // WiFi ì—°ê²° ì‹œì‘
    Serial.printf("WiFi ì—°ê²° ì‹œë„: %s\n", WIFI_SSID);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    
    // ì—°ê²° ëŒ€ê¸°
    unsigned long startTime = millis();
    Serial.print("ì—°ê²° ì¤‘");
    
    while (WiFi.status() != WL_CONNECTED && 
           (millis() - startTime) < WIFI_TIMEOUT) {
        delay(500);
        Serial.print(".");
    }
    
    Serial.println();
    
    // ì—°ê²° ê²°ê³¼ í™•ì¸
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("âœ… WiFi ì—°ê²° ì„±ê³µ!");
        printWiFiInfo();
    } else {
        Serial.println("âŒ WiFi ì—°ê²° ì‹¤íŒ¨!");
        Serial.println("ì„¤ì •ì„ í™•ì¸í•˜ê³  ì¬ì‹œë„í•˜ì„¸ìš”.");
        printWiFiStatus();
    }
}

void loop() {
    // WiFi ìƒíƒœ ëª¨ë‹ˆí„°ë§ (10ì´ˆë§ˆë‹¤)
    static unsigned long lastCheck = 0;
    if (millis() - lastCheck >= 10000) {
        lastCheck = millis();
        
        if (WiFi.status() == WL_CONNECTED) {
            Serial.printf("[%lu] WiFi ì—°ê²°ë¨ - RSSI: %d dBm\n", 
                         millis(), WiFi.RSSI());
        } else {
            Serial.printf("[%lu] WiFi ì—°ê²° ëŠì–´ì§ - ì¬ì—°ê²° ì‹œë„\n", millis());
            WiFi.reconnect();
        }
    }
    
    yield();
}

void printWiFiInfo() {
    Serial.println("--- WiFi ì—°ê²° ì •ë³´ ---");
    Serial.printf("SSID: %s\n", WiFi.SSID().c_str());
    Serial.printf("IP ì£¼ì†Œ: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("ì„œë¸Œë„· ë§ˆìŠ¤í¬: %s\n", WiFi.subnetMask().toString().c_str());
    Serial.printf("ê²Œì´íŠ¸ì›¨ì´: %s\n", WiFi.gatewayIP().toString().c_str());
    Serial.printf("DNS: %s\n", WiFi.dnsIP().toString().c_str());
    Serial.printf("ì‹ í˜¸ ê°•ë„: %d dBm\n", WiFi.RSSI());
    Serial.printf("ì±„ë„: %d\n", WiFi.channel());
    Serial.println("------------------------");
}

void printWiFiStatus() {
    Serial.print("WiFi ìƒíƒœ: ");
    switch (WiFi.status()) {
        case WL_IDLE_STATUS:
            Serial.println("ëŒ€ê¸° ì¤‘");
            break;
        case WL_NO_SSID_AVAIL:
            Serial.println("SSIDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ");
            break;
        case WL_SCAN_COMPLETED:
            Serial.println("ìŠ¤ìº” ì™„ë£Œ");
            break;
        case WL_CONNECTED:
            Serial.println("ì—°ê²°ë¨");
            break;
        case WL_CONNECT_FAILED:
            Serial.println("ì—°ê²° ì‹¤íŒ¨");
            break;
        case WL_CONNECTION_LOST:
            Serial.println("ì—°ê²° ëŠì–´ì§");
            break;
        case WL_DISCONNECTED:
            Serial.println("ì—°ê²° í•´ì œë¨");
            break;
        default:
            Serial.println("ì•Œ ìˆ˜ ì—†ëŠ” ìƒíƒœ");
            break;
    }
}
```

---

### **3.3 ì„¸ ë²ˆì§¸ í…ŒìŠ¤íŠ¸: ì „ë ¥ ì†Œë¹„ ë° ì„±ëŠ¥ ì¸¡ì •**
### ESP32_PowerAndPerformance_Test
#### **ê³ ê¸‰ ëª¨ë‹ˆí„°ë§ ì½”ë“œ**
```
/*
 * Arduino Nano ESP32 ì „ë ¥ ë° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
 * í™˜ê²½: VS Code + PlatformIO
 */

#include <Arduino.h>
#include <WiFi.h>
#include <driver/adc.h>

// í…ŒìŠ¤íŠ¸ ì„¤ì •
const int TEST_DURATION = 30000;  // ê° í…ŒìŠ¤íŠ¸ 30ì´ˆ
const int SAMPLE_INTERVAL = 1000; // 1ì´ˆë§ˆë‹¤ ìƒ˜í”Œë§

// ì„±ëŠ¥ ì¹´ìš´í„°
struct PerformanceCounter {
    unsigned long loops;
    unsigned long maxLoopTime;
    unsigned long minLoopTime;
    unsigned long totalLoopTime;
};

PerformanceCounter perfCounter = {0, 0, ULONG_MAX, 0};

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n====================================");
    Serial.println("Arduino Nano ESP32 ì „ë ¥/ì„±ëŠ¥ í…ŒìŠ¤íŠ¸");
    Serial.println("====================================");
    
    // ì‹œìŠ¤í…œ ì •ë³´
    printSystemInfo();
    
    // í…ŒìŠ¤íŠ¸ ì‹œí€€ìŠ¤ ì‹¤í–‰
    testNormalOperation();
    testWiFiOperation();
    testLightSleepMode();
    
    Serial.println("ëª¨ë“  í…ŒìŠ¤íŠ¸ ì™„ë£Œ!");
}

void loop() {
    // ì„±ëŠ¥ ì¸¡ì •ì„ ìœ„í•œ ë£¨í”„
    unsigned long loopStart = micros();
    
    // ê°„ë‹¨í•œ ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    for (int i = 0; i < 100; i++) {
        float dummy = sin(i * 0.1) + cos(i * 0.1);
        (void)dummy; // ì»´íŒŒì¼ëŸ¬ ê²½ê³  ë°©ì§€
    }
    
    unsigned long loopTime = micros() - loopStart;
    updatePerformanceCounter(loopTime);
    
    // 1ì´ˆë§ˆë‹¤ ì„±ëŠ¥ ë¦¬í¬íŠ¸
    static unsigned long lastReport = 0;
    if (millis() - lastReport >= 1000) {
        lastReport = millis();
        printPerformanceReport();
    }
    
    yield();
}

void printSystemInfo() {
    Serial.println("--- ì‹œìŠ¤í…œ ì •ë³´ ---");
    Serial.printf("ì¹©: %s Rev %d\n", ESP.getChipModel(), ESP.getChipRevision());
    Serial.printf("ì½”ì–´ ìˆ˜: %d\n", ESP.getChipCores());
    Serial.printf("CPU ì£¼íŒŒìˆ˜: %d MHz\n", getCpuFrequencyMhz());
    Serial.printf("Flash: %d MB (%d MHz)\n", 
                 ESP.getFlashChipSize() / 1024 / 1024,
                 ESP.getFlashChipSpeed() / 1000000);
    Serial.printf("PSRAM: %d bytes\n", ESP.getPsramSize());
    Serial.printf("ì—¬ìœ  ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("ìµœëŒ€ í• ë‹¹ ê°€ëŠ¥: %d bytes\n", ESP.getMaxAllocHeap());
    Serial.printf("ë‚´ë¶€ ì˜¨ë„: %.1fÂ°C\n", temperatureRead());
    Serial.println("--------------------\n");
}

void testNormalOperation() {
    Serial.println("ğŸ“Š ì¼ë°˜ ë™ì‘ ëª¨ë“œ í…ŒìŠ¤íŠ¸ ì‹œì‘");
    Serial.println("ë©€í‹°ë¯¸í„°ë¡œ ì „ë¥˜ë¥¼ ì¸¡ì •í•˜ì„¸ìš” (ì˜ˆìƒ: 80-120mA)");
    
    unsigned long startTime = millis();
    unsigned long nextSample = startTime;
    
    while (millis() - startTime < TEST_DURATION) {
        // CPU ë¶€í•˜ ìƒì„±
        for (int i = 0; i < 1000; i++) {
            float calculation = sqrt(i) * sin(i * 0.01);
            (void)calculation;
        }
        
        // ìƒ˜í”Œë§
        if (millis() >= nextSample) {
            Serial.printf("ë©”ëª¨ë¦¬: %d bytes, ì˜¨ë„: %.1fÂ°C\n", 
                         ESP.getFreeHeap(), temperatureRead());
            nextSample += SAMPLE_INTERVAL;
        }
        
        yield();
    }
    
    Serial.println("âœ… ì¼ë°˜ ë™ì‘ í…ŒìŠ¤íŠ¸ ì™„ë£Œ\n");
}

void testWiFiOperation() {
    Serial.println("ğŸ“Š WiFi í™œì„± ëª¨ë“œ í…ŒìŠ¤íŠ¸ ì‹œì‘");
    Serial.println("ì˜ˆìƒ ì „ë¥˜: 120-200mA");
    
    WiFi.begin("TestNetwork", "password"); // ê°€ìƒ ë„¤íŠ¸ì›Œí¬
    
    unsigned long startTime = millis();
    unsigned long nextSample = startTime;
    
    while (millis() - startTime < TEST_DURATION) {
        // WiFi ìŠ¤ìº” í™œë™ ìœ ì§€
        if (millis() % 5000 == 0) {
            WiFi.scanNetworks(true); // ë¹„ë™ê¸° ìŠ¤ìº”
        }
        
        // ìƒ˜í”Œë§
        if (millis() >= nextSample) {
            Serial.printf("WiFi ìƒíƒœ: %d, ë©”ëª¨ë¦¬: %d bytes\n", 
                         WiFi.status(), ESP.getFreeHeap());
            nextSample += SAMPLE_INTERVAL;
        }
        
        yield();
    }
    
    WiFi.disconnect();
    Serial.println("âœ… WiFi ëª¨ë“œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ\n");
}

void testLightSleepMode() {
    Serial.println("ğŸ“Š Light Sleep ëª¨ë“œ í…ŒìŠ¤íŠ¸ ì‹œì‘");
    Serial.println("ì˜ˆìƒ ì „ë¥˜: 1-5mA");
    Serial.println("5ì´ˆ í›„ ì ˆì „ëª¨ë“œ ì§„ì… (10ì´ˆê°„)");
    
    delay(5000);
    Serial.println("ì ˆì „ëª¨ë“œ ì§„ì…...");
    Serial.flush(); // ì‹œë¦¬ì–¼ ë²„í¼ ë¹„ìš°ê¸°
    
    // Light Sleep ì„¤ì •
    esp_sleep_enable_timer_wakeup(10 * 1000000); // 10ì´ˆ
    esp_light_sleep_start();
    
    Serial.println("ì ˆì „ëª¨ë“œì—ì„œ ê¹¨ì–´ë‚¨!");
    Serial.println("âœ… Light Sleep í…ŒìŠ¤íŠ¸ ì™„ë£Œ\n");
}

void updatePerformanceCounter(unsigned long loopTime) {
    perfCounter.loops++;
    perfCounter.totalLoopTime += loopTime;
    
    if (loopTime > perfCounter.maxLoopTime) {
        perfCounter.maxLoopTime = loopTime;
    }
    
    if (loopTime < perfCounter.minLoopTime) {
        perfCounter.minLoopTime = loopTime;
    }
}

void printPerformanceReport() {
    if (perfCounter.loops > 0) {
        unsigned long avgLoopTime = perfCounter.totalLoopTime / perfCounter.loops;
        
        Serial.printf("ì„±ëŠ¥: í‰ê·  %lu Î¼s, ìµœëŒ€ %lu Î¼s, ìµœì†Œ %lu Î¼s, ì´ %lu ë£¨í”„\n",
                     avgLoopTime, perfCounter.maxLoopTime, 
                     perfCounter.minLoopTime, perfCounter.loops);
        
        // ì¹´ìš´í„° ë¦¬ì…‹
        perfCounter = {0, 0, ULONG_MAX, 0};
    }
}
```

---

## 4ï¸âƒ£ PlatformIO ê³ ê¸‰ ê¸°ëŠ¥ í™œìš©

### **4.1 ì‹œë¦¬ì–¼ í”Œë¡œí„° ì‚¬ìš©**

#### **ë°ì´í„° ì‹œê°í™” ì½”ë“œ**
```cpp
/*
 * ì‹œë¦¬ì–¼ í”Œë¡œí„°ìš© ë°ì´í„° ì¶œë ¥
 * VS Code: Ctrl+Alt+S â†’ Serial Plotter íƒ­ ì„ íƒ
 */

#include <Arduino.h>

void setup() {
    Serial.begin(115200);
    Serial.println("ì‹œê°„,CPUì˜¨ë„,ë©”ëª¨ë¦¬ì‚¬ìš©ë¥ ,ê°€ìƒì„¼ì„œê°’");
}

void loop() {
    float temperature = temperatureRead();
    float memoryUsage = (float)(ESP.getHeapSize() - ESP.getFreeHeap()) / ESP.getHeapSize() * 100;
    float virtualSensor = 50 + 20 * sin(millis() * 0.001); // ê°€ìƒ ì„¼ì„œ ë°ì´í„°
    
    // CSV í˜•íƒœë¡œ ì¶œë ¥ (í”Œë¡œí„°ì—ì„œ ê·¸ë˜í”„ë¡œ í‘œì‹œ)
    Serial.printf("%.1f,%.1f,%.1f\n", temperature, memoryUsage, virtualSensor);
    
    delay(100);
}
```

### **4.2 ë¼ì´ë¸ŒëŸ¬ë¦¬ ê´€ë¦¬**

#### **platformio.ini ê³ ê¸‰ ì„¤ì •**
```ini
[env:arduino_nano_esp32]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; ëª¨ë‹ˆí„° ì„¤ì •
monitor_speed = 115200
monitor_filters = esp32_exception_decoder

; ë¹Œë“œ ì„¤ì •
build_type = debug
build_flags = 
    -DCORE_DEBUG_LEVEL=4
    -DARDUINO_USB_CDC_ON_BOOT=1
    -DBOARD_HAS_PSRAM
    -mfix-esp32-psram-cache-issue

; ë¼ì´ë¸ŒëŸ¬ë¦¬
lib_deps = 
    hideakitai/MPU9250@^0.4.7
    madhephaestus/ESP32Servo@^0.13.0
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    br3ttb/PID@^1.2.1

; ì—…ë¡œë“œ ì„¤ì •
upload_speed = 921600
upload_port = AUTO

; ë””ë²„ê·¸ ì„¤ì • (ì„ íƒì‚¬í•­)
debug_tool = esp-prog
debug_init_break = tbreak setup
```

### **4.3 íƒœìŠ¤í¬ ì •ì˜**

#### **.vscode/tasks.json ìƒì„±**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "PIO Build",
            "type": "shell",
            "command": "platformio",
            "args": ["run"],
            "group": "build",
            "presentation": {
                "reveal": "always",
                "panel": "new"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "PIO Upload",
            "type": "shell", 
            "command": "platformio",
            "args": ["run", "--target", "upload"],
            "group": "build"
        },
        {
            "label": "PIO Monitor",
            "type": "shell",
            "command": "platformio", 
            "args": ["device", "monitor"],
            "group": "build"
        }
    ]
}
```

---

## 5ï¸âƒ£ ë¬¸ì œ í•´ê²° ë° ë””ë²„ê¹…

### **5.1 ì¼ë°˜ì ì¸ ë¬¸ì œë“¤**

#### **ë¹Œë“œ ì˜¤ë¥˜**
```bash
# ìºì‹œ í´ë¦¬ì–´
pio run --target clean

# í”Œë«í¼ ì—…ë°ì´íŠ¸
pio platform update espressif32

# ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¬ì„¤ì¹˜
pio lib uninstall [ë¼ì´ë¸ŒëŸ¬ë¦¬ëª…]
pio lib install [ë¼ì´ë¸ŒëŸ¬ë¦¬ëª…]
```

#### **ì—…ë¡œë“œ ì‹¤íŒ¨**
```bash
# í¬íŠ¸ í™•ì¸
pio device list

# ìˆ˜ë™ í¬íŠ¸ ì§€ì • (platformio.ini)
upload_port = COM3  ; Windows
; upload_port = /dev/ttyUSB0  ; Linux
```

### **5.2 ê³ ê¸‰ ë””ë²„ê¹…**

#### **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€ ì½”ë“œ**
```cpp
#include <Arduino.h>

class MemoryTracker {
private:
    size_t initialFreeHeap;
    
public:
    MemoryTracker() {
        initialFreeHeap = ESP.getFreeHeap();
    }
    
    void checkpoint(const char* label) {
        size_t currentFree = ESP.getFreeHeap();
        int diff = (int)currentFree - (int)initialFreeHeap;
        
        Serial.printf("[%s] ë©”ëª¨ë¦¬: %d bytes (ë³€í™”: %+d bytes)\n", 
                     label, currentFree, diff);
        
        if (diff < -1000) {  // 1KB ì´ìƒ ê°ì†Œì‹œ ê²½ê³ 
            Serial.println("âš ï¸  ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„± ê°ì§€!");
        }
    }
};

// ì‚¬ìš© ì˜ˆì œ
MemoryTracker memTracker;

void setup() {
    Serial.begin(115200);
    memTracker.checkpoint("ì‹œì‘");
    
    // ì´ˆê¸°í™” ì½”ë“œ...
    memTracker.checkpoint("ì´ˆê¸°í™” í›„");
}

void loop() {
    // ì£¼ê¸°ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ í™•ì¸
    static unsigned long lastCheck = 0;
    if (millis() - lastCheck >= 10000) {
        lastCheck = millis();
        memTracker.checkpoint("10ì´ˆ í›„");
    }
}
```

---

# ğŸš€ ë“œë¡  ê°œë°œ í”„ë¡œì íŠ¸ í…œí”Œë¦¿ ë° ë‹¤ìŒ ë‹¨ê³„ ê°€ì´ë“œ

## ğŸ“‹ í˜„ì¬ ìƒí™©: MPU9250 ìì„¸ ì¶”ì • ì‹œìŠ¤í…œ ì™„ë£Œ
**ë‹¤ìŒ ëª©í‘œ**: PID ì œì–´ ì‹œìŠ¤í…œ + ëª¨í„° ì œì–´ ê°œë°œ

---

## 6ï¸âƒ£ ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„

### **6.1 ì™„ì„±ëœ ë“œë¡  í”„ë¡œì íŠ¸ í…œí”Œë¦¿ ìƒì„±**

#### **ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: "ESP32_Drone_Controller_v1"**

**PlatformIO í”„ë¡œì íŠ¸ ì„¤ì •:**
```ini
; platformio.ini - ì™„ì „í•œ ë“œë¡  ì»¨íŠ¸ë¡¤ëŸ¬ ì„¤ì •
[env:arduino_nano_esp32_drone]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; ì‹œë¦¬ì–¼ ë° ëª¨ë‹ˆí„°ë§
monitor_speed = 115200
monitor_filters = esp32_exception_decoder, time
upload_speed = 921600

; ìµœì í™” ë¹Œë“œ í”Œë˜ê·¸
build_flags = 
    -DCORE_DEBUG_LEVEL=2
    -DARDUINO_USB_CDC_ON_BOOT=1
    -DCONFIG_FREERTOS_HZ=1000
    -DBOARD_HAS_PSRAM
    -Os                    ; í¬ê¸° ìµœì í™”
    -ffast-math           ; ìˆ˜í•™ ì—°ì‚° ìµœì í™”
    -DMPU9250_SPI=0       ; I2C ì‚¬ìš©

; ë“œë¡  ì „ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ì¡´ì„±
lib_deps = 
    ; ì„¼ì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬
    hideakitai/MPU9250@^0.4.7
    
    ; ëª¨í„° ì œì–´
    madhephaestus/ESP32Servo@^0.13.0
    
    ; í†µì‹  ë¼ì´ë¸ŒëŸ¬ë¦¬
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    
    ; ì œì–´ ì‹œìŠ¤í…œ
    br3ttb/PID@^1.2.1
    
    ; ìœ í‹¸ë¦¬í‹°
    paulstoffregen/Time@^1.6.1
    knolleary/PubSubClient@^2.8

; ë””ë²„ê·¸ í™˜ê²½ (ê°œë°œìš©)
[env:debug]
extends = env:arduino_nano_esp32_drone
build_type = debug
build_flags = 
    ${env:arduino_nano_esp32_drone.build_flags}
    -DCORE_DEBUG_LEVEL=4
    -DDEBUG_DRONE=1
    -DSERIAL_DEBUG=1
```

#### **ì™„ì „í•œ í”„ë¡œì íŠ¸ êµ¬ì¡°**
```
ESP32_Drone_Controller_v1/
â”œâ”€â”€ .vscode/
â”‚   â”œâ”€â”€ settings.json          # VS Code ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì„¤ì •
â”‚   â”œâ”€â”€ tasks.json            # ë¹Œë“œ íƒœìŠ¤í¬ ì •ì˜
â”‚   â”œâ”€â”€ launch.json           # ë””ë²„ê¹… ì„¤ì •
â”‚   â””â”€â”€ extensions.json       # ì¶”ì²œ í™•ì¥ í”„ë¡œê·¸ë¨
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ config.h              # ì „ì—­ ì„¤ì •ê°’
â”‚   â”œâ”€â”€ pins.h                # í•€ ë§¤í•‘ ì •ì˜
â”‚   â”œâ”€â”€ sensors/
â”‚   â”‚   â”œâ”€â”€ imu_sensor.h      # IMU ì„¼ì„œ ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â””â”€â”€ sensor_fusion.h   # ì„¼ì„œ ìœµí•© ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ control/
â”‚   â”‚   â”œâ”€â”€ pid_controller.h  # PID ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ flight_modes.h    # ë¹„í–‰ ëª¨ë“œ ì •ì˜
â”‚   â”‚   â””â”€â”€ motor_mixer.h     # ëª¨í„° ë¯¹ì‹± ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ communication/
â”‚   â”‚   â”œâ”€â”€ receiver.h        # ìˆ˜ì‹ ê¸° ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ telemetry.h       # í…”ë ˆë©”íŠ¸ë¦¬ ì‹œìŠ¤í…œ
â”‚   â”‚   â””â”€â”€ web_interface.h   # ì›¹ ì¸í„°í˜ì´ìŠ¤
â”‚   â””â”€â”€ safety/
â”‚       â”œâ”€â”€ failsafe.h        # ì•ˆì „ ì‹œìŠ¤í…œ
â”‚       â””â”€â”€ battery_monitor.h # ë°°í„°ë¦¬ ëª¨ë‹ˆí„°ë§
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp              # ë©”ì¸ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
â”‚   â”œâ”€â”€ sensors/
â”‚   â”‚   â”œâ”€â”€ imu_sensor.cpp
â”‚   â”‚   â””â”€â”€ sensor_fusion.cpp
â”‚   â”œâ”€â”€ control/
â”‚   â”‚   â”œâ”€â”€ pid_controller.cpp
â”‚   â”‚   â”œâ”€â”€ flight_modes.cpp
â”‚   â”‚   â””â”€â”€ motor_mixer.cpp
â”‚   â”œâ”€â”€ communication/
â”‚   â”‚   â”œâ”€â”€ receiver.cpp
â”‚   â”‚   â”œâ”€â”€ telemetry.cpp
â”‚   â”‚   â””â”€â”€ web_interface.cpp
â”‚   â””â”€â”€ safety/
â”‚       â”œâ”€â”€ failsafe.cpp
â”‚       â””â”€â”€ battery_monitor.cpp
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ DroneCore/            # ì‚¬ìš©ì ì •ì˜ ë“œë¡  ì½”ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬
â”‚       â”œâ”€â”€ DroneCore.h
â”‚       â””â”€â”€ DroneCore.cpp
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ test_sensors/         # ì„¼ì„œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_control/         # ì œì–´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_integration/     # í†µí•© í…ŒìŠ¤íŠ¸
â”œâ”€â”€ data/                     # ì›¹ ì¸í„°í˜ì´ìŠ¤ íŒŒì¼
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ style.css
â”‚   â””â”€â”€ app.js
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ CALIBRATION.md
â”‚   â”œâ”€â”€ TUNING.md
â”‚   â””â”€â”€ API.md
â””â”€â”€ platformio.ini
```

### **6.2 í•µì‹¬ í—¤ë” íŒŒì¼ êµ¬ì„±**

#### **config.h - ì „ì—­ ì„¤ì •**
```cpp
#ifndef CONFIG_H
#define CONFIG_H

// í”„ë¡œì íŠ¸ ì •ë³´
#define DRONE_NAME "ESP32 Quadcopter v1.0"
#define FIRMWARE_VERSION "1.0.0"
#define BUILD_DATE __DATE__ " " __TIME__

// í•˜ë“œì›¨ì–´ ì„¤ì •
#define USE_MPU9250         1
#define USE_BAROMETER       0
#define USE_GPS             0
#define USE_OPTICAL_FLOW    0

// ì œì–´ ì£¼íŒŒìˆ˜ ì„¤ì •
#define MAIN_LOOP_RATE_HZ   1000    // ë©”ì¸ ì œì–´ ë£¨í”„
#define IMU_SAMPLE_RATE_HZ  1000    // IMU ìƒ˜í”Œë§
#define PID_RATE_HZ         500     // PID ê³„ì‚° ì£¼íŒŒìˆ˜
#define MOTOR_UPDATE_HZ     500     // ëª¨í„° ì—…ë°ì´íŠ¸
#define TELEMETRY_RATE_HZ   50      // í…”ë ˆë©”íŠ¸ë¦¬ ì „ì†¡

// ì•ˆì „ ì„¤ì •
#define FAILSAFE_TIMEOUT_MS     1000    // ìˆ˜ì‹ ê¸° ì‹ í˜¸ íƒ€ì„ì•„ì›ƒ
#define LOW_BATTERY_VOLTAGE     3.3f    // ì €ì „ì•• ê²½ê³  (V)
#define CRITICAL_BATTERY_VOLTAGE 3.0f  // ê¸´ê¸‰ì°©ë¥™ ì „ì••
#define MAX_ANGLE_LIMIT         45.0f   // ìµœëŒ€ ê¸°ìš¸ê¸° ì œí•œ (ë„)
#define MAX_RATE_LIMIT          720.0f  // ìµœëŒ€ íšŒì „ ì†ë„ (ë„/ì´ˆ)

// PID ê¸°ë³¸ê°’ (ë‚˜ì¤‘ì— íŠœë‹)
#define DEFAULT_ROLL_RATE_P     0.1f
#define DEFAULT_ROLL_RATE_I     0.05f
#define DEFAULT_ROLL_RATE_D     0.01f
#define DEFAULT_PITCH_RATE_P    0.1f
#define DEFAULT_PITCH_RATE_I    0.05f
#define DEFAULT_PITCH_RATE_D    0.01f
#define DEFAULT_YAW_RATE_P      0.15f
#define DEFAULT_YAW_RATE_I      0.02f
#define DEFAULT_YAW_RATE_D      0.0f

// ë””ë²„ê·¸ ì„¤ì •
#ifdef DEBUG_DRONE
    #define DEBUG_PRINT(x) Serial.print(x)
    #define DEBUG_PRINTLN(x) Serial.println(x)
    #define DEBUG_PRINTF(format, ...) Serial.printf(format, ##__VA_ARGS__)
#else
    #define DEBUG_PRINT(x)
    #define DEBUG_PRINTLN(x)
    #define DEBUG_PRINTF(format, ...)
#endif

#endif // CONFIG_H
```

#### **pins.h - í•€ ë§¤í•‘ ì •ì˜**
```cpp
#ifndef PINS_H
#define PINS_H

// I2C í•€ (MPU9250)
#define I2C_SDA_PIN             4
#define I2C_SCL_PIN             5

// ëª¨í„° ì¶œë ¥ í•€ (PWM/DShot)
#define MOTOR_1_PIN             25      // ì „ë°© ìš°ì¸¡
#define MOTOR_2_PIN             26      // ì „ë°© ì¢Œì¸¡
#define MOTOR_3_PIN             27      // í›„ë°© ì¢Œì¸¡
#define MOTOR_4_PIN             14      // í›„ë°© ìš°ì¸¡

// ìˆ˜ì‹ ê¸° ì…ë ¥ í•€
#define RC_INPUT_PIN            16      // SBUS/PPM ì…ë ¥
#define RC_RSSI_PIN             17      // RSSI ì•„ë‚ ë¡œê·¸ ì…ë ¥

// ìƒíƒœ í‘œì‹œ LED
#define LED_STATUS_PIN          2       // ë‚´ì¥ LED
#define LED_ARM_PIN             18      // ARM ìƒíƒœ LED
#define LED_GPS_PIN             19      // GPS ìƒíƒœ LED (ë¯¸ë˜ í™•ì¥)

// ë¶€ì € í•€
#define BUZZER_PIN              13      // ê²½ê³ ìŒ/ìƒíƒœìŒ

// ë°°í„°ë¦¬ ì „ì•• ëª¨ë‹ˆí„°ë§
#define BATTERY_VOLTAGE_PIN     A0      // ì „ì•• ë¶„ë°°ê¸° ì…ë ¥
#define BATTERY_CURRENT_PIN     A1      // ì „ë¥˜ ì„¼ì„œ ì…ë ¥ (ì˜µì…˜)

// SPI í•€ (ë¯¸ë˜ í™•ì¥ìš© - SDì¹´ë“œ, ì¶”ê°€ ì„¼ì„œ)
#define SPI_MISO_PIN            12
#define SPI_MOSI_PIN            11
#define SPI_SCLK_PIN            10
#define SPI_CS_PIN              9

// UART í•€ (GPS, í…”ë ˆë©”íŠ¸ë¦¬)
#define UART1_TX_PIN            21      // GPS TX
#define UART1_RX_PIN            20      // GPS RX
#define UART2_TX_PIN            7       // í…”ë ˆë©”íŠ¸ë¦¬ TX
#define UART2_RX_PIN            6       // í…”ë ˆë©”íŠ¸ë¦¬ RX

// ì¸í„°ëŸ½íŠ¸ í•€
#define IMU_INT_PIN             3       // MPU9250 ì¸í„°ëŸ½íŠ¸
#define RC_INT_PIN              8       // ìˆ˜ì‹ ê¸° ì¸í„°ëŸ½íŠ¸ (PPM)

#endif // PINS_H
```

### **6.3 ë©”ì¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

#### **main.cpp - ë“œë¡  ë©”ì¸ ì‹œìŠ¤í…œ**
```cpp
/*
 * ESP32 Drone Controller v1.0
 * ë©”ì¸ ì‹œìŠ¤í…œ - ë©€í‹°íƒœìŠ¤í‚¹ ì•„í‚¤í…ì²˜
 */

#include <Arduino.h>
#include <WiFi.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/semphr.h>

// í”„ë¡œì íŠ¸ í—¤ë”
#include "config.h"
#include "pins.h"
#include "sensors/imu_sensor.h"
#include "sensors/sensor_fusion.h"
#include "control/pid_controller.h"
#include "control/flight_modes.h"
#include "control/motor_mixer.h"
#include "communication/receiver.h"
#include "communication/telemetry.h"
#include "communication/web_interface.h"
#include "safety/failsafe.h"
#include "safety/battery_monitor.h"

// ì „ì—­ ê°ì²´
IMUSensor imu;
SensorFusion sensorFusion;
PIDController pidController;
FlightModes flightModes;
MotorMixer motorMixer;
Receiver receiver;
Telemetry telemetry;
WebInterface webInterface;
FailsafeSystem failsafe;
BatteryMonitor batteryMonitor;

// FreeRTOS íƒœìŠ¤í¬ í•¸ë“¤
TaskHandle_t sensorTaskHandle = NULL;
TaskHandle_t controlTaskHandle = NULL;
TaskHandle_t motorTaskHandle = NULL;
TaskHandle_t telemetryTaskHandle = NULL;
TaskHandle_t safetyTaskHandle = NULL;

// ë®¤í…ìŠ¤ ë° ì„¸ë§ˆí¬ì–´
SemaphoreHandle_t sensorDataMutex;
SemaphoreHandle_t controlDataMutex;

// ì‹œìŠ¤í…œ ìƒíƒœ êµ¬ì¡°ì²´
struct SystemState {
    // ì„¼ì„œ ë°ì´í„°
    struct {
        float roll, pitch, yaw;
        float rollRate, pitchRate, yawRate;
        float accelX, accelY, accelZ;
        bool valid;
    } attitude;
    
    // ì œì–´ ë°ì´í„°
    struct {
        float throttle;     // 0.0 ~ 1.0
        float rollCmd;      // -1.0 ~ 1.0
        float pitchCmd;     // -1.0 ~ 1.0
        float yawCmd;       // -1.0 ~ 1.0
        bool armed;
        uint8_t flightMode;
    } control;
    
    // ëª¨í„° ì¶œë ¥
    struct {
        uint16_t motor1, motor2, motor3, motor4;  // 1000-2000 Î¼s
        bool enabled;
    } motors;
    
    // ì‹œìŠ¤í…œ ìƒíƒœ
    struct {
        float batteryVoltage;
        float batteryCurrent;
        bool rcConnected;
        bool imuHealthy;
        uint32_t loopCount;
        uint16_t loopFrequency;
    } system;
};

SystemState systemState = {0};

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    printStartupBanner();
    
    // í•€ ì´ˆê¸°í™”
    initializePins();
    
    // í•˜ë“œì›¨ì–´ ì´ˆê¸°í™”
    if (!initializeHardware()) {
        Serial.println("âŒ í•˜ë“œì›¨ì–´ ì´ˆê¸°í™” ì‹¤íŒ¨!");
        while (1) {
            blinkErrorPattern();
            delay(1000);
        }
    }
    
    // FreeRTOS ë™ê¸°í™” ê°ì²´ ìƒì„±
    createSyncObjects();
    
    // ë©€í‹°íƒœìŠ¤í‚¹ ì‹œì‘
    createTasks();
    
    Serial.println("âœ… ë“œë¡  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!");
    Serial.printf("ğŸ“Š ì‚¬ìš© ê°€ëŠ¥ ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("âš¡ CPU ì£¼íŒŒìˆ˜: %d MHz\n", getCpuFrequencyMhz());
    
    // ì•ˆì „ ì²´í¬
    performSafetyCheck();
}

void loop() {
    // ë©”ì¸ ë£¨í”„ëŠ” ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ë§Œ ìˆ˜í–‰
    static unsigned long lastHeartbeat = 0;
    
    if (millis() - lastHeartbeat >= 5000) {  // 5ì´ˆë§ˆë‹¤
        lastHeartbeat = millis();
        printSystemStatus();
        
        // í•˜íŠ¸ë¹„íŠ¸ LED
        digitalWrite(LED_STATUS_PIN, !digitalRead(LED_STATUS_PIN));
        
        // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì²´í¬
        if (ESP.getFreeHeap() < 50000) {  // 50KB ë¯¸ë§Œ ì‹œ ê²½ê³ 
            Serial.println("âš ï¸  ë©”ëª¨ë¦¬ ë¶€ì¡± ê²½ê³ !");
        }
    }
    
    // ì‹œìŠ¤í…œ ì•ˆì „ ì²´í¬
    if (!systemState.system.imuHealthy || 
        systemState.system.batteryVoltage < LOW_BATTERY_VOLTAGE) {
        // ê¸´ê¸‰ ìƒí™© ì²˜ë¦¬
        handleEmergency();
    }
    
    delay(100);  // ë©”ì¸ ë£¨í”„ëŠ” 10Hz
}

// ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ íƒœìŠ¤í¬ (ìµœê³  ìš°ì„ ìˆœìœ„, ì½”ì–´ 0)
void sensorTask(void *parameter) {
    Serial.println("ğŸ“Š ì„¼ì„œ íƒœìŠ¤í¬ ì‹œì‘ (ì½”ì–´ 0)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / IMU_SAMPLE_RATE_HZ);
    
    uint32_t loopCounter = 0;
    unsigned long lastFreqCheck = millis();
    
    while (true) {
        // IMU ë°ì´í„° ì½ê¸°
        if (imu.update()) {
            // ì„¼ì„œ ìœµí•© ìˆ˜í–‰
            sensorFusion.update(
                imu.getAccelX(), imu.getAccelY(), imu.getAccelZ(),
                imu.getGyroX(), imu.getGyroY(), imu.getGyroZ(),
                imu.getMagX(), imu.getMagY(), imu.getMagZ()
            );
            
            // ê³µìœ  ë°ì´í„° ì—…ë°ì´íŠ¸
            if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.attitude.roll = sensorFusion.getRoll();
                systemState.attitude.pitch = sensorFusion.getPitch();
                systemState.attitude.yaw = sensorFusion.getYaw();
                
                systemState.attitude.rollRate = imu.getGyroX();
                systemState.attitude.pitchRate = imu.getGyroY();
                systemState.attitude.yawRate = imu.getGyroZ();
                
                systemState.attitude.accelX = imu.getAccelX();
                systemState.attitude.accelY = imu.getAccelY();
                systemState.attitude.accelZ = imu.getAccelZ();
                
                systemState.attitude.valid = true;
                systemState.system.imuHealthy = true;
                
                // ì£¼íŒŒìˆ˜ ê³„ì‚°
                if (millis() - lastFreqCheck >= 1000) {
                    systemState.system.loopFrequency = loopCounter;
                    loopCounter = 0;
                    lastFreqCheck = millis();
                }
                systemState.system.loopCount = ++loopCounter;
                
                xSemaphoreGive(sensorDataMutex);
            }
        } else {
            // IMU í†µì‹  ì˜¤ë¥˜
            systemState.system.imuHealthy = false;
            DEBUG_PRINTLN("âš ï¸  IMU í†µì‹  ì˜¤ë¥˜");
        }
        
        // ì •í™•í•œ íƒ€ì´ë° ìœ ì§€
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// ë¹„í–‰ ì œì–´ íƒœìŠ¤í¬ (ë†’ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 0)
void controlTask(void *parameter) {
    Serial.println("ğŸ® ì œì–´ íƒœìŠ¤í¬ ì‹œì‘ (ì½”ì–´ 0)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / PID_RATE_HZ);
    
    while (true) {
        // ìˆ˜ì‹ ê¸° ë°ì´í„° ì½ê¸°
        receiver.update();
        
        // Failsafe ì²´í¬
        bool rcValid = failsafe.checkReceiver(receiver.isConnected());
        systemState.system.rcConnected = rcValid;
        
        if (rcValid && systemState.attitude.valid) {
            // ìˆ˜ì‹ ê¸° ì…ë ¥ ê°€ì ¸ì˜¤ê¸°
            float throttleInput = receiver.getThrottle();
            float rollInput = receiver.getRoll();
            float pitchInput = receiver.getPitch();
            float yawInput = receiver.getYaw();
            bool armSwitch = receiver.getArmSwitch();
            
            // ë¹„í–‰ ëª¨ë“œ ì²˜ë¦¬
            uint8_t currentMode = flightModes.update(receiver.getFlightModeSwitch());
            
            // ARM/DISARM ë¡œì§
            bool shouldArm = armSwitch && 
                           systemState.system.imuHealthy && 
                           systemState.system.batteryVoltage > LOW_BATTERY_VOLTAGE &&
                           throttleInput < 0.1f;  // ìŠ¤ë¡œí‹€ì´ ë‚®ì„ ë•Œë§Œ ARM ê°€ëŠ¥
            
            // ê³µìœ  ë°ì´í„°ì—ì„œ í˜„ì¬ ìì„¸ ì½ê¸°
            float currentRoll, currentPitch, currentYaw;
            float currentRollRate, currentPitchRate, currentYawRate;
            
            if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                currentRoll = systemState.attitude.roll;
                currentPitch = systemState.attitude.pitch;
                currentYaw = systemState.attitude.yaw;
                currentRollRate = systemState.attitude.rollRate;
                currentPitchRate = systemState.attitude.pitchRate;
                currentYawRate = systemState.attitude.yawRate;
                xSemaphoreGive(sensorDataMutex);
            }
            
            // PID ì œì–´ ê³„ì‚°
            float rollOutput = 0, pitchOutput = 0, yawOutput = 0;
            
            if (shouldArm) {
                // ë¹„í–‰ ëª¨ë“œì— ë”°ë¥¸ ì œì–´
                switch (currentMode) {
                    case FLIGHT_MODE_STABILIZE:
                        // ê°ë„ ì œì–´ ëª¨ë“œ
                        rollOutput = pidController.calculateAngleControl(
                            rollInput * MAX_ANGLE_LIMIT, currentRoll, currentRollRate
                        );
                        pitchOutput = pidController.calculateAngleControl(
                            pitchInput * MAX_ANGLE_LIMIT, currentPitch, currentPitchRate
                        );
                        yawOutput = pidController.calculateRateControl(
                            yawInput * MAX_RATE_LIMIT, currentYawRate
                        );
                        break;
                        
                    case FLIGHT_MODE_ACRO:
                        // ê°ì†ë„ ì œì–´ ëª¨ë“œ
                        rollOutput = pidController.calculateRateControl(
                            rollInput * MAX_RATE_LIMIT, currentRollRate
                        );
                        pitchOutput = pidController.calculateRateControl(
                            pitchInput * MAX_RATE_LIMIT, currentPitchRate
                        );
                        yawOutput = pidController.calculateRateControl(
                            yawInput * MAX_RATE_LIMIT, currentYawRate
                        );
                        break;
                }
            }
            
            // ì œì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
            if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.control.throttle = shouldArm ? throttleInput : 0.0f;
                systemState.control.rollCmd = rollOutput;
                systemState.control.pitchCmd = pitchOutput;
                systemState.control.yawCmd = yawOutput;
                systemState.control.armed = shouldArm;
                systemState.control.flightMode = currentMode;
                xSemaphoreGive(controlDataMutex);
            }
        } else {
            // RC ì—°ê²° ì—†ìŒ ë˜ëŠ” ì„¼ì„œ ì˜¤ë¥˜ - ì•ˆì „ ëª¨ë“œ
            if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.control.throttle = 0.0f;
                systemState.control.rollCmd = 0.0f;
                systemState.control.pitchCmd = 0.0f;
                systemState.control.yawCmd = 0.0f;
                systemState.control.armed = false;
                xSemaphoreGive(controlDataMutex);
            }
        }
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// ëª¨í„° ì¶œë ¥ íƒœìŠ¤í¬ (ë†’ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
void motorTask(void *parameter) {
    Serial.println("âš¡ ëª¨í„° íƒœìŠ¤í¬ ì‹œì‘ (ì½”ì–´ 1)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / MOTOR_UPDATE_HZ);
    
    while (true) {
        // ì œì–´ ëª…ë ¹ ì½ê¸°
        float throttle, rollCmd, pitchCmd, yawCmd;
        bool armed;
        
        if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
            throttle = systemState.control.throttle;
            rollCmd = systemState.control.rollCmd;
            pitchCmd = systemState.control.pitchCmd;
            yawCmd = systemState.control.yawCmd;
            armed = systemState.control.armed;
            xSemaphoreGive(controlDataMutex);
        }
        
        // ëª¨í„° ë¯¹ì‹±
        uint16_t motor1, motor2, motor3, motor4;
        if (armed) {
            motorMixer.mix(throttle, rollCmd, pitchCmd, yawCmd, 
                          motor1, motor2, motor3, motor4);
        } else {
            motor1 = motor2 = motor3 = motor4 = 1000;  // ì •ì§€
        }
        
        // ëª¨í„° ì¶œë ¥
        motorMixer.output(motor1, motor2, motor3, motor4);
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        systemState.motors.motor1 = motor1;
        systemState.motors.motor2 = motor2;
        systemState.motors.motor3 = motor3;
        systemState.motors.motor4 = motor4;
        systemState.motors.enabled = armed;
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// í…”ë ˆë©”íŠ¸ë¦¬ ë° í†µì‹  íƒœìŠ¤í¬ (ë‚®ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
void telemetryTask(void *parameter) {
    Serial.println("ğŸ“¡ í…”ë ˆë©”íŠ¸ë¦¬ íƒœìŠ¤í¬ ì‹œì‘ (ì½”ì–´ 1)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / TELEMETRY_RATE_HZ);
    
    while (true) {
        // í…”ë ˆë©”íŠ¸ë¦¬ ë°ì´í„° ì „ì†¡
        telemetry.sendAttitude(systemState.attitude.roll, 
                             systemState.attitude.pitch, 
                             systemState.attitude.yaw);
        
        telemetry.sendBatteryStatus(systemState.system.batteryVoltage,
                                  systemState.system.batteryCurrent);
        
        telemetry.sendSystemStatus(systemState.system.loopFrequency,
                                 ESP.getFreeHeap());
        
        // ì›¹ ì¸í„°í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸
        webInterface.updateData(systemState);
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// ì•ˆì „ ë° ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ (ì¤‘ê°„ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
void safetyTask(void *parameter) {
    Serial.println("ğŸ›¡ï¸  ì•ˆì „ íƒœìŠ¤í¬ ì‹œì‘ (ì½”ì–´ 1)");
    
    while (true) {
        // ë°°í„°ë¦¬ ëª¨ë‹ˆí„°ë§
        systemState.system.batteryVoltage = batteryMonitor.getVoltage();
        systemState.system.batteryCurrent = batteryMonitor.getCurrent();
        
        // ë°°í„°ë¦¬ ì•ŒëŒ
        if (systemState.system.batteryVoltage < CRITICAL_BATTERY_VOLTAGE) {
            // ê¸´ê¸‰ ì°©ë¥™ ëª¨ë“œ
            handleCriticalBattery();
        } else if (systemState.system.batteryVoltage < LOW_BATTERY_VOLTAGE) {
            // ì €ì „ì•• ê²½ê³ ìŒ
            batteryMonitor.playLowVoltageAlarm();
        }
        
        // Failsafe ì‹œìŠ¤í…œ ì²´í¬
        failsafe.update();
        
        // ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
        checkSystemHealth();
        
        vTaskDelay(pdMS_TO_TICKS(100));  // 10Hz
    }
}

// í—¬í¼ í•¨ìˆ˜ë“¤
void printStartupBanner() {
    Serial.println("\n" + String("=").repeat(60));
    Serial.println("ğŸš " + String(DRONE_NAME));
    Serial.println("ğŸ“¦ íŒì›¨ì–´ ë²„ì „: " + String(FIRMWARE_VERSION));
    Serial.println("ğŸ—ï¸  ë¹Œë“œ: " + String(BUILD_DATE));
    Serial.println("ğŸ’» í”Œë«í¼: ESP32 Arduino + PlatformIO");
    Serial.println("=".repeat(60));
}

void initializePins() {
    // LED í•€
    pinMode(LED_STATUS_PIN, OUTPUT);
    pinMode(LED_ARM_PIN, OUTPUT);
    
    // ë¶€ì €
    pinMode(BUZZER_PIN, OUTPUT);
    
    // ë°°í„°ë¦¬ ëª¨ë‹ˆí„°ë§
    pinMode(BATTERY_VOLTAGE_PIN, INPUT);
    
    Serial.println("âœ… GPIO í•€ ì´ˆê¸°í™” ì™„ë£Œ");
}

bool initializeHardware() {
    Serial.println("ğŸ”§ í•˜ë“œì›¨ì–´ ì´ˆê¸°í™” ì¤‘...");
    
    // IMU ì´ˆê¸°í™”
    if (!imu.init()) {
        Serial.println("âŒ IMU ì„¼ì„œ ì´ˆê¸°í™” ì‹¤íŒ¨");
        return false;
    }
    Serial.println("âœ… IMU ì„¼ì„œ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // ì„¼ì„œ ìœµí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    sensorFusion.init();
    Serial.println("âœ… ì„¼ì„œ ìœµí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // PID ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™”
    pidController.init();
    Serial.println("âœ… PID ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // ëª¨í„° ë¯¹ì„œ ì´ˆê¸°í™”
    if (!motorMixer.init()) {
        Serial.println("âŒ ëª¨í„° ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨");
        return false;
    }
    Serial.println("âœ… ëª¨í„° ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // ìˆ˜ì‹ ê¸° ì´ˆê¸°í™”
    if (!receiver.init()) {
        Serial.println("âŒ ìˆ˜ì‹ ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨");
        return false;
    }
    Serial.println("âœ… ìˆ˜ì‹ ê¸° ì´ˆê¸°í™” ì™„ë£Œ");
    
    // í…”ë ˆë©”íŠ¸ë¦¬ ì´ˆê¸°í™”
    telemetry.init();
    Serial.println("âœ… í…”ë ˆë©”íŠ¸ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // ì›¹ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™”
    webInterface.init();
    Serial.println("âœ… ì›¹ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ");
    
    // ì•ˆì „ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    failsafe.init();
    batteryMonitor.init();
    Serial.println("âœ… ì•ˆì „ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ");
    
    return true;
}

void createSyncObjects() {
    sensorDataMutex = xSemaphoreCreateMutex();
    controlDataMutex = xSemaphoreCreateMutex();
    
    if (sensorDataMutex == NULL || controlDataMutex == NULL) {
        Serial.println("âŒ ë®¤í…ìŠ¤ ìƒì„± ì‹¤íŒ¨!");
        while (1) delay(1000);
    }
    
    Serial.println("âœ… FreeRTOS ë™ê¸°í™” ê°ì²´ ìƒì„± ì™„ë£Œ");
}

void createTasks() {
    BaseType_t result;
    
    // ì„¼ì„œ íƒœìŠ¤í¬ (ìµœê³  ìš°ì„ ìˆœìœ„, ì½”ì–´ 0)
    result = xTaskCreatePinnedToCore(
        sensorTask,
        "SensorTask",
        8192,                           // 8KB ìŠ¤íƒ
        NULL,
        configMAX_PRIORITIES - 1,       // ìµœê³  ìš°ì„ ìˆœìœ„
        &sensorTaskHandle,
        0                               // ì½”ì–´ 0
    );
    if (result != pdPASS) {
        Serial.println("âŒ ì„¼ì„œ íƒœìŠ¤í¬ ìƒì„± ì‹¤íŒ¨!");
        return;
    }
    
    // ì œì–´ íƒœìŠ¤í¬ (ë†’ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 0)
    result = xTaskCreatePinnedToCore(
        controlTask,
        "ControlTask",
        6144,                           // 6KB ìŠ¤íƒ
        NULL,
        configMAX_PRIORITIES - 2,       // ë‘ ë²ˆì§¸ ë†’ì€ ìš°ì„ ìˆœìœ„
        &controlTaskHandle,
        0                               // ì½”ì–´ 0 (ì„¼ì„œì™€ ê°™ì€ ì½”ì–´)
    );
    if (result != pdPASS) {
        Serial.println("âŒ ì œì–´ íƒœìŠ¤í¬ ìƒì„± ì‹¤íŒ¨!");
        return;
    }
    
    // ëª¨í„° íƒœìŠ¤í¬ (ë†’ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
    result = xTaskCreatePinnedToCore(
        motorTask,
        "MotorTask",
        4096,                           // 4KB ìŠ¤íƒ
        NULL,
        configMAX_PRIORITIES - 2,       // ë†’ì€ ìš°ì„ ìˆœìœ„
        &motorTaskHandle,
        1                               // ì½”ì–´ 1
    );
    if (result != pdPASS) {
        Serial.println("âŒ ëª¨í„° íƒœìŠ¤í¬ ìƒì„± ì‹¤íŒ¨!");
        return;
    }
    
    // í…”ë ˆë©”íŠ¸ë¦¬ íƒœìŠ¤í¬ (ì¤‘ê°„ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
    result = xTaskCreatePinnedToCore(
        telemetryTask,
        "TelemetryTask",
        6144,                           // 6KB ìŠ¤íƒ (ì›¹ í†µì‹ ìš©)
        NULL,
        2,                              // ì¤‘ê°„ ìš°ì„ ìˆœìœ„
        &telemetryTaskHandle,
        1                               // ì½”ì–´ 1
    );
    if (result != pdPASS) {
        Serial.println("âŒ í…”ë ˆë©”íŠ¸ë¦¬ íƒœìŠ¤í¬ ìƒì„± ì‹¤íŒ¨!");
        return;
    }
    
    // ì•ˆì „ íƒœìŠ¤í¬ (ë‚®ì€ ìš°ì„ ìˆœìœ„, ì½”ì–´ 1)
    result = xTaskCreatePinnedToCore(
        safetyTask,
        "SafetyTask",
        3072,                           // 3KB ìŠ¤íƒ
        NULL,
        1,                              // ë‚®ì€ ìš°ì„ ìˆœìœ„
        &safetyTaskHandle,
        1                               // ì½”ì–´ 1
    );
    if (result != pdPASS) {
        Serial.println("âŒ ì•ˆì „ íƒœìŠ¤í¬ ìƒì„± ì‹¤íŒ¨!");
        return;
    }
    
    Serial.println("âœ… ëª¨ë“  FreeRTOS íƒœìŠ¤í¬ ìƒì„± ì™„ë£Œ");
    
    // íƒœìŠ¤í¬ ìƒì„± í›„ ë©”ëª¨ë¦¬ ìƒíƒœ ì¶œë ¥
    Serial.printf("ğŸ“Š íƒœìŠ¤í¬ ìƒì„± í›„ ì—¬ìœ  ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
}

void performSafetyCheck() {
    Serial.println("\nğŸ” ì‹œìŠ¤í…œ ì•ˆì „ ì ê²€ ì¤‘...");
    
    bool safetyOK = true;
    
    // IMU ìƒíƒœ ì²´í¬
    if (!systemState.system.imuHealthy) {
        Serial.println("âŒ IMU ì„¼ì„œ ë¶ˆì•ˆì •");
        safetyOK = false;
    } else {
        Serial.println("âœ… IMU ì„¼ì„œ ì •ìƒ");
    }
    
    // ë°°í„°ë¦¬ ì „ì•• ì²´í¬
    float voltage = batteryMonitor.getVoltage();
    if (voltage < LOW_BATTERY_VOLTAGE) {
        Serial.printf("âŒ ë°°í„°ë¦¬ ì „ì•• ë¶€ì¡±: %.2fV\n", voltage);
        safetyOK = false;
    } else {
        Serial.printf("âœ… ë°°í„°ë¦¬ ì „ì•• ì •ìƒ: %.2fV\n", voltage);
    }
    
    // ìˆ˜ì‹ ê¸° ì—°ê²° ì²´í¬ (5ì´ˆ ëŒ€ê¸°)
    Serial.println("ğŸ“¡ ìˆ˜ì‹ ê¸° ì—°ê²° í™•ì¸ ì¤‘... (5ì´ˆ ëŒ€ê¸°)");
    unsigned long startTime = millis();
    bool rcDetected = false;
    
    while (millis() - startTime < 5000) {
        receiver.update();
        if (receiver.isConnected()) {
            rcDetected = true;
            break;
        }
        delay(100);
    }
    
    if (!rcDetected) {
        Serial.println("âš ï¸  ìˆ˜ì‹ ê¸° ì‹ í˜¸ ì—†ìŒ (í…ŒìŠ¤íŠ¸ ëª¨ë“œì—ì„œ ê³„ì† ì§„í–‰)");
    } else {
        Serial.println("âœ… ìˆ˜ì‹ ê¸° ì—°ê²° ì •ìƒ");
    }
    
    // ë©”ëª¨ë¦¬ ì²´í¬
    uint32_t freeHeap = ESP.getFreeHeap();
    if (freeHeap < 80000) {  // 80KB ë¯¸ë§Œ ì‹œ ê²½ê³ 
        Serial.printf("âš ï¸  ì—¬ìœ  ë©”ëª¨ë¦¬ ë¶€ì¡±: %d bytes\n", freeHeap);
    } else {
        Serial.printf("âœ… ë©”ëª¨ë¦¬ ìƒíƒœ ì–‘í˜¸: %d bytes\n", freeHeap);
    }
    
    if (safetyOK) {
        Serial.println("âœ… ëª¨ë“  ì•ˆì „ ì ê²€ í†µê³¼!");
        // ì„±ê³µ ì‹ í˜¸ìŒ
        playStartupTone();
    } else {
        Serial.println("âš ï¸  ì¼ë¶€ ì•ˆì „ ì ê²€ ì‹¤íŒ¨ - ì£¼ì˜í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”");
        // ê²½ê³  ì‹ í˜¸ìŒ
        playWarningTone();
    }
    
    Serial.println("=".repeat(60) + "\n");
}

void printSystemStatus() {
    Serial.println("\nğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ ë¦¬í¬íŠ¸");
    Serial.println("-".repeat(50));
    
    // ì„¼ì„œ ìƒíƒœ
    Serial.printf("IMU ì£¼íŒŒìˆ˜: %d Hz\n", systemState.system.loopFrequency);
    Serial.printf("ìì„¸: R=%.1fÂ° P=%.1fÂ° Y=%.1fÂ°\n", 
                 systemState.attitude.roll, 
                 systemState.attitude.pitch, 
                 systemState.attitude.yaw);
    
    // ì œì–´ ìƒíƒœ
    Serial.printf("ARM ìƒíƒœ: %s\n", systemState.control.armed ? "ARMED" : "DISARMED");
    Serial.printf("ë¹„í–‰ëª¨ë“œ: %d\n", systemState.control.flightMode);
    Serial.printf("ìŠ¤ë¡œí‹€: %.2f\n", systemState.control.throttle);
    
    // ëª¨í„° ìƒíƒœ
    Serial.printf("ëª¨í„°: M1=%d M2=%d M3=%d M4=%d\n",
                 systemState.motors.motor1, systemState.motors.motor2,
                 systemState.motors.motor3, systemState.motors.motor4);
    
    // ì‹œìŠ¤í…œ ìƒíƒœ
    Serial.printf("ë°°í„°ë¦¬: %.2fV\n", systemState.system.batteryVoltage);
    Serial.printf("RCì—°ê²°: %s\n", systemState.system.rcConnected ? "OK" : "FAIL");
    Serial.printf("ë©”ëª¨ë¦¬: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("ê°€ë™ì‹œê°„: %luì´ˆ\n", millis() / 1000);
    
    Serial.println("-".repeat(50) + "\n");
}

void handleEmergency() {
    Serial.println("ğŸš¨ ë¹„ìƒ ìƒí™© ë°œìƒ!");
    
    // ëª¨ë“  ëª¨í„° ì¦‰ì‹œ ì •ì§€
    systemState.control.armed = false;
    systemState.control.throttle = 0.0f;
    
    // ê²½ê³ ìŒ ì¬ìƒ
    playEmergencyTone();
    
    // LED ì ë©¸
    for (int i = 0; i < 10; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        digitalWrite(LED_ARM_PIN, HIGH);
        delay(100);
        digitalWrite(LED_STATUS_PIN, LOW);
        digitalWrite(LED_ARM_PIN, LOW);
        delay(100);
    }
}

void handleCriticalBattery() {
    Serial.println("ğŸª« ë°°í„°ë¦¬ ìœ„í—˜ ìˆ˜ì¤€ - ê¸´ê¸‰ ì°©ë¥™!");
    
    // ì„œì„œíˆ ìŠ¤ë¡œí‹€ ê°ì†Œí•˜ì—¬ ë¶€ë“œëŸ½ê²Œ ì°©ë¥™
    if (systemState.control.armed) {
        float currentThrottle = systemState.control.throttle;
        if (currentThrottle > 0.3f) {
            systemState.control.throttle = currentThrottle * 0.95f;  // 5%ì”© ê°ì†Œ
        }
    }
    
    // ë°°í„°ë¦¬ ìœ„í—˜ ì‹ í˜¸ìŒ
    playCriticalBatteryTone();
}

void checkSystemHealth() {
    // íƒœìŠ¤í¬ ìƒíƒœ ì²´í¬
    if (sensorTaskHandle != NULL) {
        eTaskState state = eTaskGetState(sensorTaskHandle);
        if (state == eSuspended || state == eDeleted) {
            Serial.println("âŒ ì„¼ì„œ íƒœìŠ¤í¬ ë¹„ì •ìƒ!");
        }
    }
    
    if (controlTaskHandle != NULL) {
        eTaskState state = eTaskGetState(controlTaskHandle);
        if (state == eSuspended || state == eDeleted) {
            Serial.println("âŒ ì œì–´ íƒœìŠ¤í¬ ë¹„ì •ìƒ!");
        }
    }
    
    // ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ì²´í¬
    UBaseType_t highWaterMark = uxTaskGetStackHighWaterMark(sensorTaskHandle);
    if (highWaterMark < 512) {  // 512 bytes ë¯¸ë§Œ ë‚¨ìŒ
        Serial.printf("âš ï¸  ì„¼ì„œ íƒœìŠ¤í¬ ìŠ¤íƒ ë¶€ì¡±: %d bytes ë‚¨ìŒ\n", highWaterMark);
    }
}

void blinkErrorPattern() {
    // SOS íŒ¨í„´ìœ¼ë¡œ ì—ëŸ¬ í‘œì‹œ
    // ì§§ì€ ê¹œë¹¡ì„ 3ë²ˆ (S)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(200);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
    
    delay(500);
    
    // ê¸´ ê¹œë¹¡ì„ 3ë²ˆ (O)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(600);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
    
    delay(500);
    
    // ì§§ì€ ê¹œë¹¡ì„ 3ë²ˆ (S)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(200);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
}

// ì‹ í˜¸ìŒ í•¨ìˆ˜ë“¤
void playStartupTone() {
    // ì‹œì‘ ì„±ê³µ ë©œë¡œë””
    int melody[] = {262, 330, 392, 523};  // C, E, G, C (ë†’ì€ìŒ)
    int duration[] = {200, 200, 200, 400};
    
    for (int i = 0; i < 4; i++) {
        tone(BUZZER_PIN, melody[i], duration[i]);
        delay(duration[i] + 50);
    }
    noTone(BUZZER_PIN);
}

void playWarningTone() {
    // ê²½ê³ ìŒ (ë‘ ë²ˆì˜ ë¹„í”„ìŒ)
    for (int i = 0; i < 2; i++) {
        tone(BUZZER_PIN, 800, 300);
        delay(400);
    }
    noTone(BUZZER_PIN);
}

void playEmergencyTone() {
    // ê¸´ê¸‰ ìƒí™© ì‚¬ì´ë Œ
    for (int i = 0; i < 5; i++) {
        tone(BUZZER_PIN, 1000, 200);
        delay(100);
        tone(BUZZER_PIN, 500, 200);
        delay(100);
    }
    noTone(BUZZER_PIN);
}

void playCriticalBatteryTone() {
    // ë°°í„°ë¦¬ ìœ„í—˜ ê²½ê³ ìŒ
    tone(BUZZER_PIN, 400, 1000);  // ë‚®ê³  ê¸´ ê²½ê³ ìŒ
    delay(1100);
    noTone(BUZZER_PIN);
}
```

---

## ğŸ¯ 7ï¸âƒ£ ë‹¤ìŒ ë‹¨ê³„ ë¡œë“œë§µ

### **7.1 Phase 5: PID ì œì–´ ì‹œìŠ¤í…œ êµ¬í˜„ (1-2ì£¼)**

#### **ìš°ì„ ìˆœìœ„ 1: PID ì»¨íŠ¸ë¡¤ëŸ¬ í´ë˜ìŠ¤ êµ¬í˜„**
```cpp
// include/control/pid_controller.h êµ¬í˜„ ì˜ˆì‹œ
class PIDController {
private:
    struct PIDGains {
        float kp, ki, kd;
        float integral;
        float prevError;
        float integralLimit;
    };
    
    PIDGains rollRate, pitchRate, yawRate;
    PIDGains rollAngle, pitchAngle;
    
public:
    void init();
    void setRateGains(float p, float i, float d, int axis);
    void setAngleGains(float p, float i, float d, int axis);
    float calculateRateControl(float setpoint, float measured, int axis);
    float calculateAngleControl(float angleSetpoint, float currentAngle, float currentRate);
    void reset();
};
```

#### **ìš°ì„ ìˆœìœ„ 2: ëª¨í„° ë¯¹ì‹± ì‹œìŠ¤í…œ**
```cpp
// include/control/motor_mixer.h êµ¬í˜„ ì˜ˆì‹œ  
class MotorMixer {
private:
    uint16_t minPulse = 1000;
    uint16_t maxPulse = 2000;
    
public:
    bool init();
    void mix(float throttle, float roll, float pitch, float yaw,
             uint16_t& motor1, uint16_t& motor2, uint16_t& motor3, uint16_t& motor4);
    void output(uint16_t m1, uint16_t m2, uint16_t m3, uint16_t m4);
    void setLimits(uint16_t min, uint16_t max);
};
```

### **7.2 Phase 6: ìˆ˜ì‹ ê¸° ë° í†µì‹  ì‹œìŠ¤í…œ (1-2ì£¼)**

#### **SBUS/PPM ìˆ˜ì‹ ê¸° ì¸í„°í˜ì´ìŠ¤**
```cpp
// include/communication/receiver.h
class Receiver {
private:
    float channels[8];
    bool connected = false;
    unsigned long lastUpdate = 0;
    
public:
    bool init();
    void update();
    bool isConnected();
    float getThrottle();    // ì±„ë„ 1
    float getRoll();        // ì±„ë„ 2  
    float getPitch();       // ì±„ë„ 3
    float getYaw();         // ì±„ë„ 4
    bool getArmSwitch();    // ì±„ë„ 5
    uint8_t getFlightModeSwitch();  // ì±„ë„ 6
};
```

### **7.3 Phase 7: ì‹¤ì œ í•˜ë“œì›¨ì–´ í…ŒìŠ¤íŠ¸ (2-3ì£¼)**

#### **ë‹¨ê³„ì  í…ŒìŠ¤íŠ¸ ê³„íš**
1. **ë²¤ì¹˜ í…ŒìŠ¤íŠ¸**: í”„ë¡œí ëŸ¬ ì—†ì´ ëª¨í„° ì‘ë‹µ í™•ì¸
2. **ë¡œí”„ í…ŒìŠ¤íŠ¸**: ì•ˆì „ ë¡œí”„ ì—°ê²°í•˜ì—¬ ì‹¤ì œ ì¶”ë ¥ í…ŒìŠ¤íŠ¸  
3. **ì²« í˜¸ë²„ë§**: ìˆ˜ë™ ì¡°ì‘ìœ¼ë¡œ ì§§ì€ í˜¸ë²„ë§
4. **PID íŠœë‹**: ì‹¤ì œ ë¹„í–‰ ë°ì´í„°ë¡œ íŒŒë¼ë¯¸í„° ìµœì í™”
5. **ê³ ê¸‰ ë¹„í–‰**: ë‹¤ì–‘í•œ ë¹„í–‰ ëª¨ë“œ í…ŒìŠ¤íŠ¸

### **7.4 Phase 8: ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€ (3-4ì£¼)**

#### **ì¶”ê°€ ê¸°ëŠ¥ ê°œë°œ ìˆœì„œ**
1. **ê³ ë„ ìœ ì§€ ëª¨ë“œ** (ê¸°ì•• ì„¼ì„œ ì¶”ê°€)
2. **GPS ìœ„ì¹˜ ìœ ì§€** (GPS ëª¨ë“ˆ ì¶”ê°€)  
3. **ìë™ ë³µê·€ ê¸°ëŠ¥** (RTL - Return to Launch)
4. **ì›¨ì´í¬ì¸íŠ¸ ë¹„í–‰** (ììœ¨ ë¹„í–‰)
5. **FPV ì¹´ë©”ë¼ í†µí•©** (Walksnail Avatar ì—°ë™)

---

## ğŸ› ï¸ 8ï¸âƒ£ ê°œë°œ í™˜ê²½ ìµœì í™”

### **8.1 VS Code ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì„¤ì •**

#### **.vscode/settings.json**
```json
{
    "C_Cpp.intelliSenseEngine": "Default",
    "C_Cpp.default.defines": [
        "ARDUINO=183",
        "ARDUINO_ARCH_ESP32",
        "ESP32",
        "ARDUINO_NANO_ESP32"
    ],
    "C_Cpp.default.includePath": [
        "${workspaceFolder}/include",
        "${workspaceFolder}/src",
        "${workspaceFolder}/.pio/libdeps/arduino_nano_esp32_drone/*/src",
        "${workspaceFolder}/.pio/libdeps/arduino_nano_esp32_drone/*/include"
    ],
    "files.associations": {
        "*.ino": "cpp",
        "*.h": "cpp",
        "*.hpp": "cpp"
    },
    "editor.tabSize": 4,
    "editor.insertSpaces": true,
    "files.exclude": {
        ".pio": true,
        ".vscode/.browse.c_cpp.db*": true
    },
    "terminal.integrated.env.windows": {
        "PATH": "${env:PATH};${workspaceFolder}\\.pio\\build\\arduino_nano_esp32_drone"
    }
}
```

#### **.vscode/tasks.json**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "PIO: Build",
            "type": "shell",
            "command": "platformio",
            "args": ["run"],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "PIO: Upload",
            "type": "shell",
            "command": "platformio",
            "args": ["run", "--target", "upload"],
            "group": "build",
            "dependsOn": "PIO: Build"
        },
        {
            "label": "PIO: Clean",
            "type": "shell",
            "command": "platformio",
            "args": ["run", "--target", "clean"]
        },
        {
            "label": "PIO: Test",
            "type": "shell",
            "command": "platformio",
            "args": ["test"],
            "group": "test"
        },
        {
            "label": "PIO: Monitor",
            "type": "shell",
            "command": "platformio",
            "args": ["device", "monitor", "--baud", "115200"],
            "group": "build"
        }
    ]
}
```

### **8.2 Git ë²„ì „ ê´€ë¦¬ ì„¤ì •**

#### **.gitignore**
```gitignore
# PlatformIO
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json

# ì„ì‹œ íŒŒì¼
*.tmp
*.log
*.bak

# ê°œì¸ ì„¤ì •
secrets.h
wifi_config.h

# ë¹Œë“œ ê²°ê³¼ë¬¼
*.bin
*.elf
*.map

# ìš´ì˜ì²´ì œ
.DS_Store
Thumbs.db
```

---

## ğŸ“š 9ï¸âƒ£ í•™ìŠµ ë¦¬ì†ŒìŠ¤ ë° ì°¸ê³  ìë£Œ

### **9.1 í•„ìˆ˜ í•™ìŠµ ìë£Œ**
1. **PID ì œì–´ ì´ë¡ **: Brett Beauregardì˜ PID íŠœí† ë¦¬ì–¼
2. **ì¿¼ë“œì½¥í„° ë™ì—­í•™**: MIT OpenCourseWare - Controls
3. **ESP32 FreeRTOS**: Espressif ê³µì‹ ë¬¸ì„œ
4. **ë“œë¡  ê°œë°œ**: ArduPilot/Betaflight ì†ŒìŠ¤ ì½”ë“œ ë¶„ì„

### **9.2 ìœ ìš©í•œ ë„êµ¬ë“¤**
1. **Betaflight Configurator**: PID íŠœë‹ ì°¸ê³ ìš©
2. **Mission Planner**: í…”ë ˆë©”íŠ¸ë¦¬ ë¶„ì„
3. **QGroundControl**: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
4. **Logic Analyzer**: ì‹ í˜¸ ë¶„ì„ (PPM/SBUS)

---

## ğŸ¯ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### **í˜„ì¬ ì™„ë£Œëœ ê²ƒë“¤** âœ…
```
â–¡ VS Code + PlatformIO ê°œë°œ í™˜ê²½ êµ¬ì¶•
â–¡ Arduino Nano ESP32 ê¸°ë³¸ ë™ì‘ í™•ì¸
â–¡ MPU9250 ì„¼ì„œ ì—°ê²° ë° ë°ì´í„° ì½ê¸°
â–¡ ê³ ê¸‰ ìì„¸ ì¶”ì • ì‹œìŠ¤í…œ (ìƒë³´í•„í„°/ì¹¼ë§Œí•„í„°)
â–¡ ì‹¤ì‹œê°„ ì›¹ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
â–¡ ë©€í‹°ì½”ì–´ ìµœì í™” (1000Hz ì„¼ì„œ ë£¨í”„)
â–¡ ì™„ì „í•œ í”„ë¡œì íŠ¸ í…œí”Œë¦¿ êµ¬ì¡°
```

### **ë‹¤ìŒì— í•´ì•¼ í•  ì¼ë“¤** ğŸ¯
```
â–¡ PID ì»¨íŠ¸ë¡¤ëŸ¬ í´ë˜ìŠ¤ êµ¬í˜„
â–¡ ëª¨í„° ë¯¹ì‹± ì‹œìŠ¤í…œ êµ¬í˜„  
â–¡ DShot í”„ë¡œí† ì½œ ëª¨í„° ì œì–´
â–¡ SBUS/PPM ìˆ˜ì‹ ê¸° ì¸í„°í˜ì´ìŠ¤
â–¡ ë¹„í–‰ ëª¨ë“œ ì‹œìŠ¤í…œ (Stabilize/Acro)
â–¡ ì•ˆì „ ì‹œìŠ¤í…œ (Failsafe/Battery Monitor)
â–¡ ì‹¤ì œ í•˜ë“œì›¨ì–´ ì¡°ë¦½ ë° í…ŒìŠ¤íŠ¸
â–¡ PID íŒŒë¼ë¯¸í„° íŠœë‹
â–¡ ì²« í˜¸ë²„ë§ í…ŒìŠ¤íŠ¸
```

**ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰ ì´ì œ ì™„ë²½í•œ ë“œë¡  ê°œë°œ í”„ë¡œì íŠ¸ í…œí”Œë¦¿ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ì¸ PID ì œì–´ ì‹œìŠ¤í…œ ê°œë°œë¡œ ì§„í–‰í•  ì¤€ë¹„ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!**
# ğŸš€ Arduino Nano ESP32 ë“œë¡  ê°œë°œ ì™„ì „ ë¡œë“œë§µ

## ğŸ¯ ëª©í‘œ: 10-12ë¶„ ë¹„í–‰ DIY ë“œë¡  ì™„ì„±

**ì „ì²´ ê°œë°œ ê¸°ê°„**: 12-16ì£¼  
**êµ¬ë§¤í•œ í‚¤íŠ¸**: Arduino Nano ESP32 + MPU9250 + SunFounder ESP32 Starter Kit

---

## ğŸ—“ï¸ Phase 1: ê¸°ì´ˆ í•˜ë“œì›¨ì–´ ê²€ì¦ (1-2ì£¼)

### Week 1: í™˜ê²½ ì„¤ì • ë° ê¸°ë³¸ í…ŒìŠ¤íŠ¸

#### **1.1 ê°œë°œ í™˜ê²½ êµ¬ì¶•**
```bash
ê°œë°œ ë„êµ¬ ì„¤ì¹˜:
âœ… ESP32 ë³´ë“œ íŒ¨í‚¤ì§€ (2.0.14+)
âœ… Git (ë²„ì „ ê´€ë¦¬)
âœ… VS Code + PlatformIO + Arduino í™•ì¥ (ì˜µì…˜)

í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬:
â€¢ MPU9250 by hideakitai
â€¢ ESP32Servo
â€¢ ArduinoJson
â€¢ AsyncTCP
â€¢ ESPAsyncWebServer
â€¢ PID by Brett Beauregard
```

#### **1.2 í•˜ë“œì›¨ì–´ ì—°ê²° í…ŒìŠ¤íŠ¸**
```cpp
í…ŒìŠ¤íŠ¸ í•­ëª©:
âœ… Arduino Nano ESP32 ë¶€íŒ… í…ŒìŠ¤íŠ¸
âœ… LED ì ë©¸ (ë‚´ì¥ LED)
âœ… ì‹œë¦¬ì–¼ í†µì‹  í™•ì¸
âœ… WiFi ì—°ê²° í…ŒìŠ¤íŠ¸
âœ… ì „ë ¥ ì†Œë¹„ ì¸¡ì • (ë©€í‹°ë¯¸í„° ì‚¬ìš©)

ì‚¬ìš©í•  SunFounder í‚¤íŠ¸ ë¶€í’ˆ:
â€¢ ë¸Œë ˆë“œë³´ë“œ
â€¢ ì í¼ ì™€ì´ì–´
â€¢ LED
â€¢ ì €í•­
â€¢ ë©€í‹°ë¯¸í„°
```

#### **1.3 MPU9250 ì„¼ì„œ í…ŒìŠ¤íŠ¸**
```cpp
// ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸ ì½”ë“œ
#include "MPU9250.h"

MPU9250 mpu;

void setup() {
    Serial.begin(115200);
    Wire.begin();
    
    if (mpu.setup(0x68)) {
        Serial.println("MPU9250 ì—°ê²° ì„±ê³µ!");
    } else {
        Serial.println("MPU9250 ì—°ê²° ì‹¤íŒ¨!");
    }
}

void loop() {
    if (mpu.update()) {
        Serial.print("Accel: ");
        Serial.print(mpu.getAccX()); Serial.print(", ");
        Serial.print(mpu.getAccY()); Serial.print(", ");
        Serial.println(mpu.getAccZ());
        
        Serial.print("Gyro: ");
        Serial.print(mpu.getGyroX()); Serial.print(", ");
        Serial.print(mpu.getGyroY()); Serial.print(", ");
        Serial.println(mpu.getGyroZ());
    }
    delay(100);
}
```

### Week 2: ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ë° ë¶„ì„

#### **2.1 ì„¼ì„œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜**
```cpp
ê°œë°œ ëª©í‘œ:
âœ… ê°€ì†ë„ê³„ ì˜¤í”„ì…‹ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
âœ… ìì´ë¡œìŠ¤ì½”í”„ ë“œë¦¬í”„íŠ¸ ë³´ì •
âœ… ìë ¥ê³„ í•˜ë“œ/ì†Œí”„íŠ¸ ì•„ì´ì–¸ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
âœ… ì˜¨ë„ ë³´ìƒ ì•Œê³ ë¦¬ì¦˜

ì‚¬ìš©í•  í‚¤íŠ¸ ë¶€í’ˆ:
â€¢ OLED ë””ìŠ¤í”Œë ˆì´ (ì‹¤ì‹œê°„ ë°ì´í„° í‘œì‹œ)
â€¢ ë²„íŠ¼ (ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘/ì¤‘ì§€)
â€¢ í¬í…ì…”ë¯¸í„° (íŒŒë¼ë¯¸í„° ì¡°ì •)
```

#### **2.2 ì‹¤ì‹œê°„ ë°ì´í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ**
```cpp
ê¸°ëŠ¥ êµ¬í˜„:
âœ… ì›¹ ì„œë²„ êµ¬ì¶• (ESP32 AP ëª¨ë“œ)
âœ… ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°
âœ… 3D ìì„¸ ì‹œê°í™” (ì›¹ ê¸°ë°˜)
âœ… ë°ì´í„° ë¡œê¹… (SDì¹´ë“œ ë˜ëŠ” SPIFFS)

ì›¹ ì¸í„°í˜ì´ìŠ¤ ê¸°ëŠ¥:
â€¢ ì‹¤ì‹œê°„ ê·¸ë˜í”„ (Chart.js)
â€¢ ì„¼ì„œ ìƒíƒœ ëª¨ë‹ˆí„°ë§
â€¢ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì œì–´ íŒ¨ë„
```

---

## ğŸ§  Phase 2: ìì„¸ ì¶”ì • ì•Œê³ ë¦¬ì¦˜ (3-4ì£¼)

### Week 3: ê¸°ë³¸ í•„í„°ë§ êµ¬í˜„

#### **3.1 ì €ì—­ í†µê³¼ í•„í„°**
```cpp
class LowPassFilter {
private:
    float alpha;
    float prev_output;
    
public:
    LowPassFilter(float cutoff_freq, float dt) {
        float RC = 1.0 / (2.0 * PI * cutoff_freq);
        alpha = dt / (dt + RC);
        prev_output = 0.0;
    }
    
    float update(float input) {
        prev_output = alpha * input + (1.0 - alpha) * prev_output;
        return prev_output;
    }
};

êµ¬í˜„ í•­ëª©:
âœ… ê°€ì†ë„ê³„ ë…¸ì´ì¦ˆ í•„í„°ë§ (20Hz ì»·ì˜¤í”„)
âœ… ìì´ë¡œìŠ¤ì½”í”„ ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ ì œê±°
âœ… í•„í„° íŒŒë¼ë¯¸í„° ì‹¤ì‹œê°„ ì¡°ì •
```

#### **3.2 ìƒë³´ í•„í„° êµ¬í˜„**
```cpp
class ComplementaryFilter {
private:
    float alpha;
    float roll, pitch, yaw;
    float dt;
    
public:
    void update(float acc_x, float acc_y, float acc_z,
                float gyro_x, float gyro_y, float gyro_z) {
        
        // ê°€ì†ë„ê³„ë¡œë¶€í„° ê°ë„ ê³„ì‚°
        float acc_roll = atan2(acc_y, acc_z);
        float acc_pitch = atan2(-acc_x, sqrt(acc_y*acc_y + acc_z*acc_z));
        
        // ìì´ë¡œìŠ¤ì½”í”„ ì ë¶„
        roll += gyro_x * dt;
        pitch += gyro_y * dt;
        yaw += gyro_z * dt;
        
        // ìƒë³´ í•„í„° ì ìš©
        roll = alpha * roll + (1.0 - alpha) * acc_roll;
        pitch = alpha * pitch + (1.0 - alpha) * acc_pitch;
    }
};
```

### Week 4: ê³ ê¸‰ ìì„¸ ì¶”ì •

#### **4.1 ì¿¼í„°ë‹ˆì–¸ ê¸°ë°˜ ìì„¸ ì¶”ì •**
```cpp
class QuaternionFilter {
private:
    float q0, q1, q2, q3;  // ì¿¼í„°ë‹ˆì–¸ ìš”ì†Œ
    float beta;            // í•„í„° ê²Œì¸
    
public:
    void madgwickUpdate(float gx, float gy, float gz,
                       float ax, float ay, float az,
                       float mx, float my, float mz);
    
    void getRollPitchYaw(float& roll, float& pitch, float& yaw);
};

êµ¬í˜„ ëª©í‘œ:
âœ… Madgwick AHRS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
âœ… ìë ¥ê³„ ë°ì´í„° í“¨ì „
âœ… ê¹€ë²Œë½ ë°©ì§€
âœ… ë“œë¦¬í”„íŠ¸ ìµœì†Œí™” (Â±1ë„ ì´ë‚´)
```

#### **4.2 ì¹¼ë§Œ í•„í„° (ì„ íƒì‚¬í•­)**
```cpp
ê³ ê¸‰ ê¸°ëŠ¥:
âœ… í™•ì¥ ì¹¼ë§Œ í•„í„° êµ¬í˜„
âœ… ì„¼ì„œ ë…¸ì´ì¦ˆ ëª¨ë¸ë§
âœ… ë™ì  í™˜ê²½ ì ì‘
âœ… ì˜ˆì¸¡-ë³´ì • ì‚¬ì´í´ ìµœì í™”
```

---

## ğŸ® Phase 3: ì œì–´ ì‹œìŠ¤í…œ ê°œë°œ (5-7ì£¼)

### Week 5: PID ì»¨íŠ¸ë¡¤ëŸ¬ ê¸°ì´ˆ

#### **5.1 Single-axis PID êµ¬í˜„**
```cpp
class PIDController {
private:
    float kp, ki, kd;
    float integral, prev_error;
    float dt;
    float integral_limit;  // ì ë¶„ í¬í™” ë°©ì§€
    
public:
    float update(float setpoint, float measured_value) {
        float error = setpoint - measured_value;
        
        // ë¹„ë¡€í•­
        float proportional = kp * error;
        
        // ì ë¶„í•­ (windup ë°©ì§€)
        integral += error * dt;
        integral = constrain(integral, -integral_limit, integral_limit);
        float integral_term = ki * integral;
        
        // ë¯¸ë¶„í•­
        float derivative = (error - prev_error) / dt;
        float derivative_term = kd * derivative;
        
        prev_error = error;
        
        return proportional + integral_term + derivative_term;
    }
};

í…ŒìŠ¤íŠ¸ ë°©ë²•:
â€¢ ì„œë³´ëª¨í„°ë¡œ ê°ë„ ì œì–´ í…ŒìŠ¤íŠ¸
â€¢ ìŠ¤í… ì‘ë‹µ ì¸¡ì •
â€¢ ì˜¤ë²„ìŠˆíŠ¸, ì •ì°©ì‹œê°„ ë¶„ì„
```

#### **5.2 3-axis ìì„¸ ì œì–´**
```cpp
êµ¬í˜„ ê¸°ëŠ¥:
âœ… Roll PID ì»¨íŠ¸ë¡¤ëŸ¬
âœ… Pitch PID ì»¨íŠ¸ë¡¤ëŸ¬  
âœ… Yaw PID ì»¨íŠ¸ë¡¤ëŸ¬
âœ… Rate PID (ê°ì†ë„ ì œì–´)
âœ… Angle PID (ê°ë„ ì œì–´)

ì‚¬ìš©í•  í‚¤íŠ¸ ë¶€í’ˆ:
â€¢ ì„œë³´ëª¨í„° 3ê°œ (ê° ì¶• ì‹œë®¬ë ˆì´ì…˜)
â€¢ í¬í…ì…”ë¯¸í„° (PID ê²Œì¸ ì¡°ì •)
â€¢ LCD ë””ìŠ¤í”Œë ˆì´ (PID íŒŒë¼ë¯¸í„° í‘œì‹œ)
```

### Week 6: ëª¨í„° ì œì–´ ì‹œìŠ¤í…œ

#### **6.1 DShot í”„ë¡œí† ì½œ êµ¬í˜„**
```cpp
class DShot {
private:
    static const int DSHOT_FRAME_SIZE = 16;
    static const int DSHOT_DMA_BUFFER_SIZE = 18;
    
public:
    void init(int pin);
    void writeThrottle(int pin, uint16_t throttle);
    uint16_t prepareDShotPacket(uint16_t throttle);
    void sendDShotPacket(int pin, uint16_t packet);
};

êµ¬í˜„ ëª©í‘œ:
âœ… DShot600/1200 í”„ë¡œí† ì½œ
âœ… ì²´í¬ì„¬ ê²€ì¦
âœ… í…”ë ˆë©”íŠ¸ë¦¬ ìˆ˜ì‹  (ì„ íƒì‚¬í•­)
âœ… 4ì±„ë„ ë™ì‹œ ì¶œë ¥

í…ŒìŠ¤íŠ¸ ë°©ë²•:
â€¢ ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ë¡œ ì‹ í˜¸ ê²€ì¦
â€¢ ë‹¨ì¼ ESC ì—°ê²° í…ŒìŠ¤íŠ¸
â€¢ ìŠ¤ë¡œí‹€ ì‘ë‹µ ì¸¡ì •
```

#### **6.2 ëª¨í„° ë¯¹ì‹± ì•Œê³ ë¦¬ì¦˜**
```cpp
class QuadMotorMixer {
public:
    struct MotorOutput {
        float motor1, motor2, motor3, motor4;
    };
    
    MotorOutput mix(float throttle, float roll, float pitch, float yaw) {
        MotorOutput output;
        
        // X êµ¬ì„± ì¿¼ë“œì½¥í„° ë¯¹ì‹±
        output.motor1 = throttle - roll - pitch + yaw;  // ì „ë°© ìš°ì¸¡
        output.motor2 = throttle + roll - pitch - yaw;  // ì „ë°© ì¢Œì¸¡  
        output.motor3 = throttle + roll + pitch + yaw;  // í›„ë°© ì¢Œì¸¡
        output.motor4 = throttle - roll + pitch - yaw;  // í›„ë°© ìš°ì¸¡
        
        // ì¶œë ¥ ì œí•œ
        output.motor1 = constrain(output.motor1, 0, 1000);
        output.motor2 = constrain(output.motor2, 0, 1000);
        output.motor3 = constrain(output.motor3, 0, 1000);
        output.motor4 = constrain(output.motor4, 0, 1000);
        
        return output;
    }
};
```

### Week 7: ë¹„í–‰ ëª¨ë“œ êµ¬í˜„

#### **7.1 ë¹„í–‰ ëª¨ë“œ ì‹œìŠ¤í…œ**
```cpp
enum FlightMode {
    DISARMED,
    STABILIZE,  // ìì„¸ ì•ˆì •í™”
    ACRO,       // ê°ì†ë„ ì œì–´
    ALTITUDE,   // ê³ ë„ ìœ ì§€
    POSITION    // ìœ„ì¹˜ ìœ ì§€
};

class FlightController {
private:
    FlightMode current_mode;
    PIDController roll_rate_pid, pitch_rate_pid, yaw_rate_pid;
    PIDController roll_angle_pid, pitch_angle_pid, yaw_angle_pid;
    
public:
    void update();
    void setMode(FlightMode mode);
    void armMotors();
    void disarmMotors();
};
```

#### **7.2 ì•ˆì „ ì‹œìŠ¤í…œ**
```cpp
ì•ˆì „ ê¸°ëŠ¥ êµ¬í˜„:
âœ… Failsafe ì‹œìŠ¤í…œ (ìˆ˜ì‹ ê¸° ì‹ í˜¸ ì†ì‹¤)
âœ… ë°°í„°ë¦¬ ì „ì•• ëª¨ë‹ˆí„°ë§
âœ… ìì„¸ ì œí•œ (ìµœëŒ€ ê°ë„ ì„¤ì •)
âœ… ëª¨í„° ì˜¨ë„ ë³´í˜¸
âœ… í¬ë˜ì‹œ ê°ì§€ ë° ìë™ ë””ìŠ¤ì•”

ì‚¬ìš©í•  í‚¤íŠ¸ ë¶€í’ˆ:
â€¢ ë²„ì € (ì•ŒëŒ)
â€¢ LED (ìƒíƒœ í‘œì‹œ)
â€¢ ì „ì•• ë¶„ë°°ê¸° (ë°°í„°ë¦¬ ëª¨ë‹ˆí„°ë§)
```

---

## ğŸ“¡ Phase 4: í†µì‹  ì‹œìŠ¤í…œ (8-9ì£¼)

### Week 8: ìˆ˜ì‹ ê¸° ì¸í„°í˜ì´ìŠ¤

#### **8.1 ë‹¤ì¤‘ í”„ë¡œí† ì½œ ì§€ì›**
```cpp
class ReceiverInterface {
public:
    virtual void init() = 0;
    virtual bool isConnected() = 0;
    virtual void getChannels(uint16_t channels[8]) = 0;
};

class PPMReceiver : public ReceiverInterface {
    // PPM ì‹ í˜¸ ë””ì½”ë”©
};

class SBUSReceiver : public ReceiverInterface {  
    // SBUS í”„ë¡œí† ì½œ ì²˜ë¦¬
};

class CRSFReceiver : public ReceiverInterface {
    // CRSF/ELRS í”„ë¡œí† ì½œ
};

êµ¬í˜„ í”„ë¡œí† ì½œ:
âœ… PPM (Pulse Position Modulation)
âœ… SBUS (Serial Bus)
âœ… CRSF (Crossfire/ExpressLRS)

í…ŒìŠ¤íŠ¸ ë°©ë²•:
â€¢ ì‹ í˜¸ ìƒì„±ê¸°ë¡œ PPM ì‹ í˜¸ ìƒì„±
â€¢ ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ë¡œ íƒ€ì´ë° ê²€ì¦
â€¢ ì±„ë„ ë§¤í•‘ ë° ìŠ¤ì¼€ì¼ë§ í…ŒìŠ¤íŠ¸
```

#### **8.2 ì±„ë„ ë§¤í•‘ ë° ìŠ¤ì¼€ì¼ë§**
```cpp
class ChannelMapper {
private:
    struct ChannelConfig {
        uint16_t min_pulse;
        uint16_t max_pulse; 
        uint16_t center_pulse;
        bool reversed;
    };
    
    ChannelConfig channels[8];
    
public:
    float getThrottle();
    float getRoll();
    float getPitch(); 
    float getYaw();
    bool getArmSwitch();
    int getFlightMode();
};
```

### Week 9: í…”ë ˆë©”íŠ¸ë¦¬ ë° OSD

#### **9.1 MAVLink í”„ë¡œí† ì½œ**
```cpp
#include <mavlink.h>

class MAVLinkTelemetry {
public:
    void sendHeartbeat();
    void sendAttitude(float roll, float pitch, float yaw);
    void sendBatteryStatus(float voltage, float current);
    void sendGPSPosition(float lat, float lon, float alt);
    
private:
    void sendMAVLinkMessage(mavlink_message_t& msg);
};

ê¸°ëŠ¥ êµ¬í˜„:
âœ… ì‹¤ì‹œê°„ í…”ë ˆë©”íŠ¸ë¦¬ ì „ì†¡
âœ… Mission Planner í˜¸í™˜
âœ… íŒŒë¼ë¯¸í„° ì›ê²© ì¡°ì •
âœ… ë¡œê·¸ ë‹¤ìš´ë¡œë“œ
```

#### **9.2 ì›¹ ê¸°ë°˜ GCS (Ground Control Station)**
```html
<!-- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¸í„°í˜ì´ìŠ¤ -->
<!DOCTYPE html>
<html>
<head>
    <title>ë“œë¡  ì œì–´ ì‹œìŠ¤í…œ</title>
    <script src="chart.js"></script>
</head>
<body>
    <div id="attitude-display">
        <!-- 3D ìì„¸ í‘œì‹œ -->
    </div>
    
    <div id="telemetry-data">
        <!-- ì‹¤ì‹œê°„ ë°ì´í„° -->
    </div>
    
    <div id="pid-tuning">
        <!-- PID ê²Œì¸ ì¡°ì • -->
    </div>
    
    <script>
        // WebSocket ì—°ê²°
        var ws = new WebSocket('ws://192.168.1.1:81');
        
        ws.onmessage = function(event) {
            var data = JSON.parse(event.data);
            updateDisplay(data);
        };
    </script>
</body>
</html>
```

---

## ğŸ¥ Phase 5: HD ë¹„ë””ì˜¤ ì‹œìŠ¤í…œ (10-11ì£¼)

### Week 10: Walksnail Avatar ì—°ë™

#### **10.1 UART í†µì‹  ì¸í„°í˜ì´ìŠ¤**
```cpp
class WalksnailInterface {
private:
    HardwareSerial* uart_port;
    
public:
    void init(HardwareSerial* port);
    void sendOSDData(float voltage, int satellite_count, 
                    float altitude, int flight_mode);
    void setRecordingMode(bool enable);
    void adjustCameraSettings(int brightness, int contrast);
};

ê¸°ëŠ¥ êµ¬í˜„:
âœ… OSD ë°ì´í„° ì˜¤ë²„ë ˆì´
âœ… ë…¹í™” ì œì–´ (ìë™/ìˆ˜ë™)
âœ… ì¹´ë©”ë¼ ì„¤ì • ì›ê²© ì¡°ì •
âœ… ë¹„ë””ì˜¤ í’ˆì§ˆ ìµœì í™”
```

#### **10.2 HD ì´¬ì˜ ìµœì í™”**
```cpp
ì„±ëŠ¥ ìµœì í™”:
âœ… ì§„ë™ ëŒí•‘ ì•Œê³ ë¦¬ì¦˜
âœ… ì§ë²Œ ì œì–´ (ì„ íƒì‚¬í•­)
âœ… ìë™ ë…¸ì¶œ ì œì–´ ì—°ë™
âœ… ND í•„í„° ìë™ ì „í™˜

ì´¬ì˜ ëª¨ë“œ:
â€¢ ì‹œë„¤ë§ˆí‹± ëª¨ë“œ (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„)
â€¢ ìŠ¤í¬ì¸  ëª¨ë“œ (ë¹ ë¥¸ ë°˜ì‘)
â€¢ ë§¤ë‰´ì–¼ ëª¨ë“œ (ì™„ì „ ìˆ˜ë™ ì œì–´)
```

---

## ğŸ”§ Phase 6: ì‹œìŠ¤í…œ í†µí•© ë° ìµœì í™” (12-16ì£¼)

### Week 11-12: ì „ì²´ ì‹œìŠ¤í…œ í†µí•©

#### **12.1 ë©”ì¸ íŒì›¨ì–´ ì•„í‚¤í…ì²˜**
```cpp
// main.cpp - ë©”ì¸ ë£¨í”„ êµ¬ì¡°
#include "flight_controller.h"
#include "sensor_manager.h" 
#include "receiver_interface.h"
#include "telemetry_system.h"

FlightController fc;
SensorManager sensors;
ReceiverInterface* receiver;
TelemetrySystem telemetry;

void setup() {
    // í•˜ë“œì›¨ì–´ ì´ˆê¸°í™”
    sensors.init();
    receiver->init();
    telemetry.init();
    fc.init();
    
    Serial.println("ë“œë¡  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!");
}

void loop() {
    static uint32_t loop_timer = micros();
    
    // ì„¼ì„œ ë°ì´í„° ì½ê¸° (1kHz)
    sensors.update();
    
    // ìˆ˜ì‹ ê¸° ë°ì´í„° ì²˜ë¦¬
    receiver->update();
    
    // ë¹„í–‰ ì œì–´ ê³„ì‚°
    fc.update(sensors.getIMU(), receiver->getChannels());
    
    // í…”ë ˆë©”íŠ¸ë¦¬ ì „ì†¡ (50Hz)
    if (micros() - telemetry_timer > 20000) {
        telemetry.update();
        telemetry_timer = micros();
    }
    
    // ì •í™•í•œ ë£¨í”„ íƒ€ì´ë° ìœ ì§€
    while (micros() - loop_timer < 1000) {}
    loop_timer = micros();
}
```

#### **12.2 ì„±ëŠ¥ ìµœì í™”**
```cpp
ìµœì í™” í•­ëª©:
âœ… ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™” (80% ì´í•˜ ìœ ì§€)
âœ… CPU ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§ (95% ì´í•˜)
âœ… ë£¨í”„ íƒ€ì´ë° ìµœì í™” (1ms Â±10Î¼s)
âœ… ì „ë ¥ ì†Œë¹„ ìµœì í™” (ëª©í‘œ: 10ì‹œê°„ ëŒ€ê¸° ëª¨ë“œ)

ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§:
â€¢ ì‹¤ì‹œê°„ ì„±ëŠ¥ ì§€í‘œ í‘œì‹œ
â€¢ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€
â€¢ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
â€¢ Watchdog íƒ€ì´ë¨¸ êµ¬í˜„
```

### Week 13-14: ì§€ìƒ í…ŒìŠ¤íŠ¸ ë° íŠœë‹

#### **14.1 ë²¤ì¹˜ í…ŒìŠ¤íŠ¸**
```cpp
í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤:
âœ… ì„¼ì„œ ì •í™•ë„ í…ŒìŠ¤íŠ¸ (Â±1ë„ ì´ë‚´)
âœ… PID ì‘ë‹µ í…ŒìŠ¤íŠ¸ (ì˜¤ë²„ìŠˆíŠ¸ 5% ì´í•˜)
âœ… ëª¨í„° ë™ê¸°í™” í…ŒìŠ¤íŠ¸ (Â±1% ì´ë‚´)
âœ… ë°°í„°ë¦¬ ìˆ˜ëª… í…ŒìŠ¤íŠ¸ (ëª©í‘œ: 12ë¶„)
âœ… ì˜¨ë„ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ (-10Â°C ~ 60Â°C)

ì‚¬ìš©í•  í‚¤íŠ¸ ë¶€í’ˆ:
â€¢ ì˜¨ìŠµë„ ì„¼ì„œ (í™˜ê²½ ëª¨ë‹ˆí„°ë§)
â€¢ ì‹¤ì‹œê°„ í´ë¡ (ì •í™•í•œ ì‹œê°„ ì¸¡ì •)
â€¢ SDì¹´ë“œ ëª¨ë“ˆ (í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¡œê¹…)
```

#### **14.2 ìë™ íŠœë‹ ì‹œìŠ¤í…œ**
```cpp
class AutoTune {
private:
    enum TuneState {
        IDLE,
        MEASURING,
        CALCULATING,
        APPLYING
    };
    
    TuneState state;
    
public:
    void startAutoTune(int axis);
    void processStep();
    bool isComplete();
    void getPIDGains(float& p, float& i, float& d);
};

êµ¬í˜„ ê¸°ëŠ¥:
âœ… ìë™ PID íŠœë‹ (Relay/Ziegler-Nichols)
âœ… ì§„ë™ ë¶„ì„ ê¸°ë°˜ í•„í„° ì„¤ì •
âœ… ëª¨í„° ê°œë³„ ë³´ì •
âœ… ë°°í„°ë¦¬ë³„ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ ì €ì¥
```

### Week 15-16: ìµœì¢… ê²€ì¦ ë° ë¬¸ì„œí™”

#### **16.1 ìµœì¢… ì‹œìŠ¤í…œ ê²€ì¦**
```cpp
ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸:
â–¡ ëª¨ë“  ì„¼ì„œ ì •ìƒ ë™ì‘
â–¡ ì œì–´ ì‘ë‹µ ì‹œê°„ < 10ms  
â–¡ ìì„¸ ì¶”ì • ì˜¤ì°¨ < 2ë„
â–¡ ë°°í„°ë¦¬ ìˆ˜ëª… > 10ë¶„
â–¡ ë¹„ìƒ ìƒí™© ëŒ€ì‘ ì •ìƒ
â–¡ HD ì˜ìƒ í’ˆì§ˆ ë§Œì¡±
â–¡ ì›ê²© ì¡°ì¢… ë²”ìœ„ > 500m
â–¡ ìë™ ë³µê·€ ê¸°ëŠ¥ ì •ìƒ

ìµœì¢… ì„±ëŠ¥ ëª©í‘œ:
â€¢ í˜¸ë²„ë§ ì •í™•ë„: Â±10cm
â€¢ ìµœëŒ€ ê²½ì‚¬ê°: 45ë„
â€¢ ìµœëŒ€ ê°ì†ë„: 720deg/s
â€¢ ë¹„í–‰ ì‹œê°„: 10-12ë¶„
â€¢ HD ë…¹í™”: 1080p@60fps
```

#### **16.2 ë¬¸ì„œí™” ë° ë°±ì—…**
```
ì™„ì„± ë¬¸ì„œ:
ğŸ“ Hardware/
  â”œâ”€â”€ Schematic.pdf
  â”œâ”€â”€ PCB_Layout.pdf
  â”œâ”€â”€ BOM.xlsx
  â””â”€â”€ Assembly_Guide.md

ğŸ“ Software/
  â”œâ”€â”€ src/ (ì „ì²´ ì†ŒìŠ¤ì½”ë“œ)
  â”œâ”€â”€ libraries/ (ì‚¬ìš©ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬)
  â”œâ”€â”€ documentation/ (API ë¬¸ì„œ)
  â””â”€â”€ examples/ (ì˜ˆì œ ì½”ë“œ)

ğŸ“ Calibration/
  â”œâ”€â”€ PID_Settings.json
  â”œâ”€â”€ Sensor_Calibration.json
  â””â”€â”€ Motor_Mapping.json

ğŸ“ Testing/
  â”œâ”€â”€ Test_Results.xlsx
  â”œâ”€â”€ Flight_Logs/
  â””â”€â”€ Performance_Analysis.pdf
```

---

## ğŸ“Š ê°œë°œ ì§„í–‰ë¥  ì¶”ì 

### **ë§ˆì¼ìŠ¤í†¤ ì²´í¬ë¦¬ìŠ¤íŠ¸**

#### **Phase 1 ì™„ë£Œ ê¸°ì¤€**
- [ ] Arduino Nano ESP32 ì •ìƒ ë¶€íŒ…
- [ ] MPU9250 ì„¼ì„œ ë°ì´í„° ì½ê¸° ì„±ê³µ
- [ ] ê¸°ë³¸ ì›¹ ì„œë²„ êµ¬ë™
- [ ] ì‹¤ì‹œê°„ ì„¼ì„œ ëª¨ë‹ˆí„°ë§

#### **Phase 2 ì™„ë£Œ ê¸°ì¤€**  
- [ ] ìì„¸ ì¶”ì • ì˜¤ì°¨ < 3ë„
- [ ] ìƒë³´/ì¹¼ë§Œ í•„í„° ì •ìƒ ë™ì‘
- [ ] ë“œë¦¬í”„íŠ¸ ë³´ì • íš¨ê³¼ í™•ì¸
- [ ] 3D ìì„¸ ì‹œê°í™” ì™„ë£Œ

#### **Phase 3 ì™„ë£Œ ê¸°ì¤€**
- [ ] PID ì œì–´ ì•ˆì •í™” ë‹¬ì„±
- [ ] DShot í”„ë¡œí† ì½œ ì •ìƒ ë™ì‘  
- [ ] ëª¨í„° ë¯¹ì‹± ì•Œê³ ë¦¬ì¦˜ ê²€ì¦
- [ ] ë¹„í–‰ ëª¨ë“œ ì „í™˜ ì •ìƒ

#### **Phase 4 ì™„ë£Œ ê¸°ì¤€**
- [ ] ìˆ˜ì‹ ê¸° ì‹ í˜¸ ì •ìƒ ìˆ˜ì‹ 
- [ ] í…”ë ˆë©”íŠ¸ë¦¬ ë°ì´í„° ì „ì†¡
- [ ] ì›¹ GCS ì™„ì „ ê¸°ëŠ¥
- [ ] ì›ê²© íŒŒë¼ë¯¸í„° ì¡°ì •

#### **Phase 5 ì™„ë£Œ ê¸°ì¤€**
- [ ] HD ì˜ìƒ ì „ì†¡ ì•ˆì •
- [ ] OSD ë°ì´í„° ì˜¤ë²„ë ˆì´
- [ ] ë…¹í™” ì œì–´ ì •ìƒ
- [ ] ì˜ìƒ í’ˆì§ˆ ìµœì í™”

#### **Phase 6 ì™„ë£Œ ê¸°ì¤€**
- [ ] ì „ì²´ ì‹œìŠ¤í…œ í†µí•©
- [ ] ì„±ëŠ¥ ìµœì í™” ì™„ë£Œ
- [ ] ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ë¬¸ì„œí™” ì™„ë£Œ

---

## ğŸš¨ ì£¼ìš” ìœ„í—˜ ìš”ì†Œ ë° ëŒ€ì‘ ë°©ì•ˆ

### **ê¸°ìˆ ì  ìœ„í—˜**
1. **ì„¼ì„œ ë…¸ì´ì¦ˆ ê³¼ë‹¤**
   - ëŒ€ì‘: í•˜ë“œì›¨ì–´ í•„í„° + ì†Œí”„íŠ¸ì›¨ì–´ í•„í„° ì¡°í•©
   
2. **ì‹¤ì‹œê°„ ì„±ëŠ¥ ë¶€ì¡±**
   - ëŒ€ì‘: FreeRTOS ë„ì…, ì½”ë“œ ìµœì í™”
   
3. **ì „ë ¥ ì†Œë¹„ ê³¼ë‹¤**
   - ëŒ€ì‘: ì €ì „ë ¥ ëª¨ë“œ êµ¬í˜„, íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜

### **í•˜ë“œì›¨ì–´ ìœ„í—˜**
1. **ë¶€í’ˆ í˜¸í™˜ì„± ë¬¸ì œ**
   - ëŒ€ì‘: ì¶©ë¶„í•œ í”„ë¡œí† íƒ€ì´í•‘, ëŒ€ì²´ ë¶€í’ˆ í™•ë³´
   
2. **ì§„ë™/ê°„ì„­ ë¬¸ì œ**  
   - ëŒ€ì‘: ì ì ˆí•œ ì°¨í, ë°°ì¹˜ ìµœì í™”

### **ê°œë°œ ì¼ì • ìœ„í—˜**
1. **ë³µì¡ë„ ê³¼ì†Œí‰ê°€**
   - ëŒ€ì‘: ë‹¨ê³„ë³„ ê°œë°œ, ìš°ì„ ìˆœìœ„ ì„¤ì •
   
2. **ë””ë²„ê¹… ì‹œê°„ ê³¼ë‹¤**
   - ëŒ€ì‘: ì¶©ë¶„í•œ ë¡œê¹…, ì‹œë®¬ë ˆì´ì…˜ í™œìš©

---

## ğŸ¯ ì„±ê³µì„ ìœ„í•œ í•µì‹¬ ì¡°ì–¸

### **ê°œë°œ ì›ì¹™**
1. **ë‹¨ê³„ì  ì ‘ê·¼**: í•œ ë²ˆì— í•˜ë‚˜ì”©, í™•ì‹¤í•˜ê²Œ
2. **ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸**: ê° ë‹¨ê³„ë§ˆë‹¤ ì² ì €í•œ ê²€ì¦
3. **ë¬¸ì„œí™”**: ëª¨ë“  ê³¼ì •ê³¼ ê²°ê³¼ ê¸°ë¡
4. **ë°±ì—…**: ì‘ë™í•˜ëŠ” ë²„ì „ í•­ìƒ ë³´ê´€

### **íš¨ìœ¨ì ì¸ ê°œë°œ**
1. **ì‹œë®¬ë ˆì´ì…˜ í™œìš©**: ì‹¤ì œ í…ŒìŠ¤íŠ¸ ì „ ì¶©ë¶„í•œ ì‹œë®¬ë ˆì´ì…˜
2. **ì»¤ë®¤ë‹ˆí‹° í™œìš©**: ë“œë¡  ê°œë°œ ì»¤ë®¤ë‹ˆí‹° ì°¸ì—¬
3. **ì˜¤í”ˆì†ŒìŠ¤ í™œìš©**: ê²€ì¦ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì ê·¹ í™œìš©
4. **ì ì§„ì  ê°œì„ **: ì™„ë²½ë³´ë‹¤ëŠ” ë™ì‘í•˜ëŠ” ê²ƒ ë¨¼ì €

**ì´ ë¡œë“œë§µì„ ë”°ë¼ê°€ë©´ ì„±ê³µì ìœ¼ë¡œ DIY ë“œë¡ ì„ ì™„ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! í™”ì´íŒ…! ğŸš€**